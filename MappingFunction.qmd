---
title: "Map"
format: html
editor: source
---
```{r}
library(dplyr)
library(stringr)
library(readxl)
library(scales)
library(ggplot2)
library(sf)
library(ggfx)
library(ggrepel)
library(grid)
library(colorspace)
library(showtext)
library(sysfonts)

font_add_google(name = "Lekton", family = "lekton")
showtext_auto()
#TO DO:
#map with per capita shading and bubbles for absolute count
#aggregate county data by state and then use state map options > merge_by_state
```

```{r}
#after writing 1000+ loc I found out much of this functionality is already built :/
#But building off of these functions wouldn't allow me to do all the things I want to do so I will keep building on this
# vignette("usmap1", package = "usmap") # 1. Introduction
# vignette("usmap2", package = "usmap") # 2. Mapping the US
# vignette("usmap3", package = "usmap") # 3. Advanced Mapping
```


###map
```{r}
#put error handling in separate function?
#make good documentation
map <- function(data, map, state_map = NULL, title, source, font_size = NA, years = NA, bubbles = T, unit = "", per = "", max_bubble_size = NA, continental = F, borders = F, palette = list(), inset_cutoff = -Inf, cutoff_column = "Value", breaks = NA, na_to_0 = F, caption_manual = "", labels_manual = NA, inset_style = "top", subtitle = NA, region_fips = NA, merge_MSAs = F, scale_center = NA, scale_factor = 1, logratio = F, dpi = 300, show_endpoints = F, hide_values = F, tag = T, plusminus_labels = list(pos = "Positive", neg = "Negative"), inset_labels = list(top = "Top /n/", bottom = "Bottom /n/"), obs_units = "auto", na_label = "No Data", inset_box = T, v_adj = 0, increment = 0) {
  palette = set_palette(palette)
  
if("fips" %in% colnames(data)){
  if (all(nchar(data$fips) == 2)) { #2 digit fips codes for states
  level <- "state"
} else if (all(nchar(data$fips) == 5)) { #5 digit fips codes for counties
  level <- "county"
} else {
  stop("FIPS codes are invalid.")
}
} else if("metro_name" %in% colnames(map)){
  level <- "MSA" #this option is if we are already merged by MSA, otherwise level is set to county first, then changes to MSA after we merge by MSA
} else if("zip_code" %in% colnames(data)) {
  level <- "ZIP"
  map <- map |>
    rename(fips = zip_code) #this is lazy but it works
} else if("geometry" %in% colnames(data)){ #geometry is the centroid in this case
  level <- "freefloating"
} else {
  stop("Data level not recognized.")
}
  cat("Level: ", level, "\n")
  
  if("Type" %in% colnames(data) & "Value" %in% colnames(data)){
    data_type = c("Type", "Value")
  } else if("Value" %in% colnames(data)){
    data_type = "Value"
  } else if("Type" %in% colnames(data)){
    data_type = "Type"
    bubbles = F #Bubble map cannot be created when only Type and not Value is supplied
  } else {
    stop("data must have Value and/or Type column.")
  }
  if(is.na(scale_center) & "Value" %in% data_type){
    if(min(data$Value, na.rm = T) < 0){
      cat("Warning: negative Values in data\n")
    }
  }
  if("Value" %in% data_type) {
    data <- data |>
      mutate(Value = Value * scale_factor) #for scaling (ex. scale_factor = 100000 for rate per 100000)
  }
  
  if(logratio){ #log ratio: use with migration type = "net", supply breaks as log of the positive ratios you want as breaks ex. c(log(1.1), log(1.3), log(1.5))
    per = "" #anything else would be silly
    unit = ":1"
  }
  
  #this code kind of sucks but idk how exactly i should handle this without adding a bunch of extra parameters
  
  caption = ""
  
  if (source == "USDA") {
    caption <- "Source: USDA Agriculture Census"
  } else if (source == "IRS") {
    if(is.na(years)[1]){ 
      years = 2012:2022 #default (data I have right now)
      first_year <- min(years)
      last_year <- max(years)
      cat("Using default years for IRS data: 2012-2022")
    }
    if(last_year > 2021 & first_year < 2021){
       caption = paste0("Connecticut data is ",first_year,"-",2021,"\n")
    }
    caption <- paste0(caption, "Source: ",first_year, "-", last_year," IRS Migration Data")
  } else if (source == "ACS") {
    if(is.na(years)[1]){
      years = 2011:2020 #default
      first_year <- min(years)
      last_year <- max(years)
      cat("Using default years for ACS data: 2011-2020\n")
    }
    caption <- "Source: ACS Migration Data"
  } else if(!is.na(years)[1]){
    #years should be a list of years. It can be specified 2019:2022 for example
    first_year <- min(years)
    last_year <- max(years)
    if(length(years) == 1){
      caption = paste0("Year: ", first_year, "\n", caption)
    } else {
      caption = paste0("Years: ", first_year, "-", last_year, "\n", caption)
    }
  }
    
  caption_manual <- ifelse(!str_detect(caption_manual, "\n$") & caption_manual != "" & caption != "", str_c(caption_manual, "\n"), caption_manual) #make sure manual caption ends in \n
  
  caption <- paste0(caption_manual, caption)
  caption = str_remove(caption, "\n$") #make sure caption doesn't end in new line
  
  if (per == "capita" & length(years) > 1 | per == "year") {
    num_years_ct = length(years[years < 2022]) #we don't have post-2021 data for CT due to the switch to planning regions, but I should write this better for post-2021 maps, but that is difficult without requiring that the data argument be un-aggregated by year
    num_years_notct = length(years)
    data <- data |>
      mutate(num_years = if_else(substr(fips, 1, 2) == "09" & level != "state", num_years_ct, num_years_notct), #CT
        Value = Value / num_years
      )
    subtitle <- if_else(is.na(subtitle) & per == "year", "Rate per year", subtitle)
  }
  
  if (!is.na(region_fips)[1]) {
      region = map |>
        filter(fips %in% region_fips) |>
        st_union()
  } else{
    region = NA
  }
  keep_cols = c("fips", data_type, cutoff_column, "geometry")
  if(level %in% c("freefloating", "MSA")){
    keep_cols = c(keep_cols, "name", "abbr")
  }
  data <- keep_columns(data, keep_cols)
  
  if(level == "MSA"){ #this option is for if data are already merged by MSA, otherwise county_map is supplied for map and merge_MSAs is true
    map = map |> #for MSA map we need to join by name because of non-metro counties
      full_join(data, by = join_by(metro_name == name)) |>
      rename(name = metro_name) #streamline this later
  } else if(level == "freefloating"){
    map = data #this should have Value and/or Type, geometry, name, abbr
  } else {
    map <- map |>
      full_join(data, by = "fips")
  } #Switched to full_join here to keep PR so that it can be in the inset at least. I don't think it will mess with the mapping.
  
  for(col in data_type){
    if(all(is.na(map[[col]]))){
      stop(paste0(col, "  is all NAs. Likely wrong map supplied. \n"))
    }
  }
  
    if("Value" %in% data_type){
    map <- map |>
      mutate(cutoff = !!sym(cutoff_column))
    }
  if(merge_MSAs){
    if("Type" %in% data_type){
      stop("Categorical data can't be merged by MSA.")
    } else if(level == "county"){ #merge_by_MSA merges a county_map by MSA
      map = merge_by_MSA(map, region_fips)
      level = "MSA"
    } else if(level == "MSA"){
      cat("Map merged by MSA already supplied, ignoring Merge_MSAs argument.")
    } else {
      stop("Only county level can be merged by MSA.")
    }
  }
  
  if (na_to_0 & "Value" %in% data_type) {
    map <- map |>
      mutate(Value = replace_na(Value, 0))
  } 

  dollar <- ""
  if (str_detect(unit, "\\$")) {
    dollar <- "$"
    unit <- str_remove(unit, "\\$")
  } else if (unit == "%") {
    map <- map |>
      mutate(Value = 100 * Value)
  } else if (!str_detect(unit, "$[/:]")) {#ratios and rates don't have the space before
    unit <- paste0(" ", unit)
  }
  
    if(per %in% c("capita", "capita_total", "year")){ #use capita_total to divide by population over a period of time but not year (ex. for cumulative % population changes over multiple years)
      if(is.na(years)[1]){
        stop("Specify which years the data are for.")
      }
      pop_cols <- paste0("pop", substr(years, 3, 4))
      map <- map %>%
        rowwise() %>%
        mutate(
          avg_pop = mean(c_across(all_of(pop_cols)), na.rm = T), #at worst we're chopping off 2 years at the end so it isn't a big deal for now
          avg_pop = ifelse(is.na(avg_pop) | avg_pop == 0, pop, avg_pop), # Default to "pop" if missing
          pop = avg_pop #if pop is the inset cutoff this matters
        ) %>%
        ungroup()
    }
  if("Value" %in% data_type){
  per_capita_result <- handle_per(map, source, per, subtitle, scale_factor)
  map <- per_capita_result$map
  subtitle <- per_capita_result$subtitle
  } else {
  inset_style = "hidden"
  }
  
  #vectorized string formatter
  format_value <- append_unit(dollar, unit)
  format_value_no_unit <- append_unit(dollar, "")
  
  if (inset_style == "hidden") {
    inset_text <- ""
  } else{ 
    obs_units = case_when(obs_units != "auto" ~ obs_units,
                      level == "county" ~ "Counties",
                      level == "MSA" ~ "Counties/MSAs",
                      level == "state" ~ "States",
                      level == "ZIP" ~ "ZIP Codes",
                      T ~ "")
    if (inset_style %in% c("top", "bottom")) {
    inset_text <- create_inset(map, level, inset_style, 10, inset_cutoff, cutoff_column, logratio, scale_center, hide_values, inset_labels, obs_units, format_value)
  } else if (inset_style == "split") {
    top <- create_inset(map, level, "top", 5, inset_cutoff, cutoff_column, logratio, scale_center, hide_values, inset_labels, obs_units, format_value)
    bottom <- create_inset(map, level, "bottom", 5, inset_cutoff, cutoff_column, logratio, scale_center, hide_values, inset_labels, obs_units, format_value)
    inset_text = paste0(top, "\n",bottom)
    }
  }
  drop_cols = c("GU", "VI", "AS", "MP")
  
  pr = map |> filter(substr(fips, 1, 2) == "72")
  if(all(is.na(pr$Value))) {
    drops_cols = c(drop_cols, "PR")
  }
  
  #THIS WILL CRASH ZIP MAP UNTIL FIXED
    if (continental) { #filter out AK, HI, and PR after inset
      if("abbr" %in% colnames(map)) {
        drop_cols = c(drop_cols, "AK", "HI", "PR")
      } else{
        for(abbr in drop_cols){
          map <- map |>
            filter(!str_detect(name, paste0(", ", abbr, "$")))
        }
      }
  state_map <- state_map |>
    filter(!abbr %in% c("AK", "HI", "PR"))
  }
  
  if("abbr" %in% colnames(map)){
    map <- map |>
      filter(!abbr %in% drop_cols) 
  } 
  map <- map |>
    filter(!st_is_empty(geometry))
  
  if (bubbles) {
    if(is.na(max_bubble_size)){
    max_bubble_size = auto_mbs(map)
  }
    plot <- bubble_map(map, state_map, level, max_bubble_size, palette, borders, region, scale_center, plusminus_labels, data_type, format_value)
  } else{
    if(is.na(max_bubble_size) & level == "freefloating"){
    max_bubble_size = min(2.5, max(1.5,10/log(nrow(map))))
  }
    choropleth <- choropleth_map(map, state_map, level, breaks, labels_manual, palette, borders, region, scale_center, logratio, show_endpoints, na_label, max_bubble_size, data_type, increment, dollar, unit, format_value, format_value_no_unit)
    plot = choropleth$plot
    breaks = choropleth$breaks
  }
  
  plot <- add_theme(plot, title, palette, subtitle, font_size, caption, inset_text, breaks, bubbles, max_bubble_size, continental, tag, level, inset_box, v_adj)
  #Maps go in map folder, sub-folders named by source
  graphicspath = paste0("Maps/", source, "/")
  if(!dir.exists(graphicspath)){
    #prompt user to create folder
    createfolder = ""
    while(!createfolder %in% c("Y", "N")){
      createfolder = readline(prompt = paste0("Create folder '", source ,"'?[Y/N]\n"))
      createfolder <- toupper(createfolder) # So it isn't case sensitive
      if(createfolder == "Y"){
        dir.create(graphicspath, recursive = T) #recursive = T means that it will create the Maps folder too if it is missing
      } else if(createfolder == "N"){
        graphicspath = ""
        cat("Outputting map to working directory.\n")
      }
    }
  }
  
  filepath = paste0(graphicspath, str_remove_all(title, "[ '()]"), source, "_", level, ".jpg")
  showtext_opts(dpi = dpi)
  ggsave(filename = filepath, plot = plot, dpi = dpi, width = 10, height = 10) #set dpi to 100 for a cool retro look
  system2("open", filepath)
}
```

#helper functions
```{r}
keep_columns <- function(df, cols_to_keep) { #because select() doesn't work if you give it columns that aren't in the data
  existing_cols <- intersect(cols_to_keep, colnames(df))
  return(df[, existing_cols, drop = FALSE])
}
auto_mbs = function(map){
  map <- map |>
    mutate(abs_value = abs(Value))
  max = max(map$abs_value, na.rm = T)
  bubble <- map |>
    select(abs_value) |>
    mutate(normalized_bubble_size = abs_value / max,
           normalized_bubble_size = replace_na(normalized_bubble_size, 0))
  inflation_factor = 3000 / sum(bubble$normalized_bubble_size) #3000 was arrived at by trial and error, and doesn't work well for maps where the data is all clustered in one area
  max_bubble_size = sqrt(max(bubble$normalized_bubble_size) * inflation_factor) #bubble size is in terms of radius not area
  cat("Auto max bubble size: ", max_bubble_size, "\n")
  return(max_bubble_size)
}
#computes midpoint color
midpoint_rgb <- function(color1, color2, weight1) {
  if(weight1 < 0 | weight1 > 1){
    stop("weight1 is the weighting on the first color and must be between 0 and 1.\n")
  }
    col1 <- col2rgb(color1)
    col2 <- col2rgb(color2)
    mid_rgb <- weight1 * col1 + (1-weight1) * col2  # Biased the mix towards the mid_color so you can see the bubbles better
    rgb(mid_rgb[1], mid_rgb[2], mid_rgb[3], maxColorValue = 255)
}
calculate_brightness <- function(color) {
  rgb_values <- col2rgb(color) / 255  # Normalize RGB values to [0,1]
  return(0.299 * rgb_values[1] + 0.587 * rgb_values[2] + 0.114 * rgb_values[3])  # Brightness formula
}
compute_bubble_breaks <- function(values) { # This is for finding good bubble sizes for the legend
  max_value <- max(values, na.rm = TRUE)
  min_value <- max(min(values , na.rm = TRUE),1)
  
  powers_of_10 <- 10^(ceiling(log10(min_value)):floor(log10(max_value)))
  
  if (max_value > 5 * max(powers_of_10)) {
    powers_of_10 <- c(powers_of_10, 5 * max(powers_of_10))
  } else if(max_value > 2 * max(powers_of_10)){
    powers_of_10 <- c(powers_of_10, 2 * max(powers_of_10))
  }
  
  breaks <- sort(unique(powers_of_10))
  if (length(breaks) > 3) {
    breaks <- tail(breaks, 3) # No more than 3 bubbles in legend
  }
  return(breaks)
}

compute_breaks <- function(values, n_breaks){
  values = sort(values)
  if(length(values) > 10){
    n = min(ceiling(length(values)/10), 10)
    topn = values[1:n]
    diffs = topn[1:n-1] - topn[2:n]
    cut_values = values[1:(length(values) - which.max(diffs) + 1)]
  }else {
    cut_values = values
  }
  max_value <- max(cut_values, na.rm = TRUE)
  min_value <- max(min(cut_values , na.rm = TRUE), 0.000001)
  powers_of_10 <- 10^(floor(log10(min_value)):floor(log10(max_value)))
  potential_breaks = c(powers_of_10, 2*powers_of_10, 5*powers_of_10)
  potential_breaks = potential_breaks[potential_breaks < max_value] #take out breaks above max value
  potential_breaks = potential_breaks[potential_breaks > min_value] #take out breaks below min value
  #maybe something where if only one observation is in the top break, then drop it
  breaks <- sort(unique(potential_breaks))
  breaks = tail(breaks, n_breaks-1)
  breaks = c(round_to_sigfigs(min(values), 2, "floor"),
                  breaks,
                  round_to_sigfigs(max(values), 2,"ceiling"))
  cat("Auto breaks: ", breaks, "\n")
  return(breaks)
}

remove_empty_breaks <- function(map, breaks){ #this code tends to cause issues. should rewrite 
  data <- map$Value
  
  # Always include the first break (minimum value)
  adjusted_breaks <- c(breaks[1])
  
  # Iterate through the breaks starting from the second break
  for (i in 2:(length(breaks) - 1)) {
    # Check if there are any values between the previous break and the current break
    if (any(data >= breaks[i - 1] & data < breaks[i], na.rm = TRUE)) {
      # if there are, keep the current break
      adjusted_breaks <- c(adjusted_breaks, breaks[i])
    }
  }
  
  # Always include the last break (maximum value)
  adjusted_breaks <- c(adjusted_breaks, breaks[length(breaks)])
  adjusted_breaks = unique(adjusted_breaks) #so that the last break doesn't end up in there twice
  
  return(adjusted_breaks)
}

# For nice-looking breakpoints for a choropleth legend (I usually hide endpoints now, but it's still good to have this functionality)
round_to_sigfigs <- function(value, sigfigs, method = c("floor", "ceiling")) {
  method <- match.arg(method)
  if (value == 0) return(0)
  
  # Calculate the scale factor based on the significant figures
  scale_factor <- 10^(floor(log10(abs(value))) - (sigfigs - 1))
  
  if (method == "floor") {
    return(floor(value / scale_factor) * scale_factor)
  } else if (method == "ceiling") {
    return(ceiling(value / scale_factor) * scale_factor)
  }
}

append_unit <- function(dollar, unit) {
  function(x) {
    sign <- ifelse(x < 0, "-", "")
    paste0(sign, dollar, shorten(abs(x)), unit)
  }
}

#vectorized it
shorten <- function(value) {
  sapply(value, function(v) {
    if (is.na(v)) return("")

    abs_val <- abs(v)

    # if (abs_val >= 1000 && abs_val < 10000) {
    #   return(comma_format()(round(v)))
    # }

    thresholds <- c(1e12, 1e9, 1e6, 1e3, 1)
    suffixes   <- c("t",   "b",  "m",  "k", "")

    for (i in seq_along(thresholds)) {
      if (abs_val >= thresholds[i]) {
        display_value <- v / thresholds[i]
        sigfigs = 3
        # sigfigs <- if (display_value >= 100) 3 else 2
        return(paste0(signif(display_value, sigfigs), suffixes[i]))
      }
    }

    return(as.character(signif(v, 2)))
  })
}

type_colors <- function(n_types){
    if(n_types < 4) {
      type_colors <- c( "#007f7f", "#0000ff", "#00ff00")[1:n_types]
    } else {
      type_colors <- viridis(n_types+1)[1:n_types] #so that the highest break isn't bright yellow
    }
  return(type_colors)
}
```

#set_palette
```{r}
set_palette <- function(user_palette) {
  default_palette <- list(
    "high_color" = "red", #forestgreen
    "mid_color" = "#FFE5B4",  # #ECE4D5 #e0df9b
    "low_color" = "blue", #  #CC5500
    "background_color" = "#E8DACC",# #f1e0cf
    "title_color" = "#363c45",
    "text_color" = "#363c45",
    "highlight_color" = "steelblue",
    "na_color" = "gray80"
  )
  return(modifyList(default_palette, user_palette))
}
```

#create_inset
```{r}
#Exclude Puerto Rico? Sometimes yes sometimes no? For county maps I don't want it to be the entire top or bottom
create_inset <- function(map, level, style = c("top", "bottom"), n, inset_cutoff, cutoff_column, logratio, scale_center, hide_values, inset_labels, obs_units, format_value) {
  
  style <- match.arg(style)
  
  # if(level == "county"){
  #   map <- map |>
  #     mutate(name = case_when(fips == "57001" ~ "Overseas",
  #                           fips == "57003" ~ "Puerto Rico",
  #                           fips == "57005" ~ "Military Deployment",
  #                           fips == "57007" ~ "U.S. Virgin Islands",
  #                           T ~ name
  #                           ))
  # }
  inset_data <- map |>
    st_drop_geometry() |>
        filter(cutoff >= inset_cutoff,
           !is.na(Value),
           !is.na(name))
  
  # Taking out DC because people complained and PR because people will complain
  if(level == "state"){
    inset_data <- inset_data |>
      filter(!fips %in% c("11", "72"))  
  }

  if(logratio){
    inset_data <- inset_data |>
      mutate(Value = exp(Value))
  }
  if (style == "top") {
    inset_data <- inset_data |>
      arrange(desc(Value))
  } else {
    inset_data <- inset_data |>
      arrange(Value)
  }
 inset_data <- inset_data |>
    mutate(
      rank_value = min_rank(if (style == "top") desc(Value) else Value),
      rank = as.character(rank_value),
      rank = if_else(rank_value < 10, paste0(rank, ".   "), paste0(rank, ". "))
    )
  
  # Expand n if ties would push beyond requested number
  last_rank_value <- inset_data$rank_value[min(n, nrow(inset_data))]
  
  # Keep only top n (now including all ties at cutoff)
  inset_data <- inset_data |>
    filter(rank_value <= last_rank_value)
  if(nrow(inset_data) > n){
    message("Expanding inset to ", n, " observations due to ties.\n")
  }
  n = nrow(inset_data)
  
inset_data <- inset_data |>
  mutate(
    plus = case_when(is.na(scale_center) ~ "",
                     scale_center == 0 & Value > 0 ~ "+",
                     T ~ ""),
    label = if (hide_values) {
      paste0(rank, name)
    } else {
      paste0(rank, name, ": ", plus, format_value(Value))
    }
  )

  topbottom = if_else(style == "top", inset_labels$top, inset_labels$bottom)
    #use /n/ to insert n
  topbottom = str_replace(topbottom, "/n/",as.character(n)) #Turn "Top /n/" into "Top 10" or "Bottom /n/" into "Bottom 5"
  if(obs_units != ""){
    topbottom = if_else(str_detect(topbottom, " $"), topbottom , paste0(topbottom, " ")) # Make sure top/bottom ends in a space
  }
  
  title_line =  paste0(topbottom, obs_units, 
                      if_else(inset_cutoff > 0, paste0(" (min ", shorten(inset_cutoff), " ", cutoff_column, ")"), ""), 
                      ":\n")
  inset <- paste0(title_line, paste(inset_data$label, collapse = "\n"))
  
  return(inset)
}
```

#add_theme
```{r}
#legend takes up too much space when it has to do color and size, covers up caption
#having issues with high max_bubble_size (> ~30), but that may be unavoidable due to space constraints

add_theme <- function(plot, title, palette, subtitle, font_size, caption, inset_text, breaks, bubbles, max_bubble_size, continental, tag, level, inset_box, v_adj) {
  
  font = "Arial"
  
  v_adj = unit(v_adj, "npc")
  
  title_height = 1.06 #I have more vertical space now
  
  if(is.na(font_size)){
    font_size = min(36*38/nchar(title), 36) #the plot is a bit more than 40 characters wide at font size 36, but at font size 36 I'd still want some breathing room so 36 characters is when I start reducing the font size (depends on the font you're using)
    #this was done using another font, I think 38 is better now
    cat("Auto font size: ", font_size,"\n")
  }
  
  if(continental) {
    title_alignment = 0.5
    left_margin = 0.025
  } else{
    title_alignment = 0.551
    left_margin = 0.128
  }
  subtitle_offset = 0.07*(font_size/36) # Vertical adjustment for subtitle
  if(continental){continental_offset = 0.11}else{continental_offset = 0}
  
  # For inset box
  inset_font_size = 11.5
  text_width <- grobWidth(textGrob(inset_text, gp = gpar(fontsize = inset_font_size))) * 1.05 # Estimate text size
  text_height <- grobHeight(textGrob(inset_text, gp = gpar(fontsize = inset_font_size)))
  
  # Define x and y positions (make text align inside the box)
  x_pos <- unit(if_else(continental, 0.55, 0.58), "npc") #continental was 0.53 but that's greedy
  y_pos <- unit(-0.14 - continental_offset, "npc")
  
  plot <- plot +
    theme_minimal(base_family = font) +
    theme(
      legend.title = element_blank(),
      legend.text = element_text(size = 14, color = palette$text_color, face = "bold"), #if_else(bubbles, 14, 12)
      # legend.position = "bottom",
      legend.position = "inside",
      legend.position.inside = c(left_margin, -0.02),
      legend.justification = "left",
      legend.direction = "horizontal",
      legend.key.width = unit(if_else(bubbles, min(sqrt(max_bubble_size)/4, 0.75), 0.5), "cm"),
      legend.key.height = unit(0.5, "cm"),
      panel.grid = element_blank(),
      panel.background = element_rect(fill = palette$background_color, color = NA), # #f1e0cf
      plot.background = element_rect(fill = palette$background_color, color = NA),
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      #legend.box.margin = margin(if_else(continental, 100, 40), 0, if_else(continental, -40, 0), if_else(continental, 0, 83)),
      legend.box.margin = margin(0, 0, 0, 0),
      plot.margin = margin(0, if_else(continental, -20, -20), 0, if_else(continental, -20, -110))
    ) +
    guides(fill = guide_legend(nrow = ceiling(length(breaks)/3))) + # I could do 4 to a row depending on the length of the text associated with the breaks, but I'd rarely want more than 9 breaks, so this is good
    coord_sf(clip = "off") +
    annotation_custom(grid::textGrob(
      title,
      gp = grid::gpar(
        fontsize = font_size,
        fontface = "bold",
        col = palette$title_color, fontfamily = font
      ),
      x = unit(title_alignment, "npc"),
      y = unit(title_height, "npc"),
      hjust = 0.5
    )) +
    annotation_custom(grid::textGrob(
      if_else(tag, "@hdk_maps", ""),
      gp = grid::gpar(fontsize = 12, col = palette$title_color, fontface = "bold", fontfamily = "lekton"),
      x = unit(title_alignment, "npc"),
      y = unit(title_height - subtitle_offset - if_else(is.na(subtitle), 0, subtitle_offset/2), "npc"), #0.034
      hjust = 0.5
     )) +
    annotation_custom(grid::textGrob(
      caption,
      gp = grid::gpar(fontsize = 10, col = palette$text_color, fontfamily = font),
      x = unit(left_margin, "npc"),
      y = unit(if_else(continental, -0.26, -0.15), "npc") + v_adj,
      hjust = 0,
      vjust = 0
    ))
  if(inset_box & inset_text != "") {
        plot = plot +
    annotation_custom(
      roundrectGrob(
        x =  x_pos - unit(0.01, "npc"),
        y = y_pos + v_adj - unit(0.01, "npc"),
        width = text_width + unit(0.02, "npc"),
        height = text_height + unit(0.02, "npc"),
        r = unit(0.03, "npc"), #0.1 is the most you can do without the corners bumping into the text but 0.03 looks better
        just = c("left", "bottom"),
        gp = gpar(fill = midpoint_rgb(palette$mid_color, palette$high_color, 0.7), col = palette$text_color, lwd = 3)
      ))
  }
    plot = plot +
    annotation_custom(
    textGrob(
      inset_text,
      x = x_pos,
      y = y_pos + v_adj, #use v_adj when freefloating map has messed up alignment to get caption and inset back to where they should be
      just = c("left", "bottom"),
      gp = gpar(
        fontsize = inset_font_size,
        fontface = "bold",
        col = palette$text_color,
        fontfamily = font)
      ))

  if (!is.na(subtitle)) {
    plot <- plot +
      annotation_custom(grid::textGrob(
        subtitle,
        gp = grid::gpar(fontsize = font_size/2, col = palette$title_color, fontface = "bold", fontfamily = font),
        x = unit(title_alignment, "npc"),
        y = unit(title_height - subtitle_offset, "npc"),
        hjust = 0.5
      ))
  }
  
  #didn't try very hard to make it work but it seems this kinda might not work if I put it in choropleth_map idk why
  if (!bubbles & level != "freefloating") {
    plot <- plot +
      theme(legend.key = element_rect(fill = NA, color = "black",  linewidth = 1.75))#changed from linewidth to size due to deprecation
  }
  
  return(plot)
}
```

#handle_per
```{r}
handle_per <- function(map, source, per, subtitle, scale_factor) {
  
  if (per %in% c("capita", "capita_total") ) {
      map <- map |> 
        mutate(Value = Value / avg_pop)
      if(scale_factor != 1){
        subtitle = paste0("Rate per ", shorten(scale_factor), if_else(per == "capita", " year", ""))
      }
    } else if (per == "acre") {
    map <- map |>
      mutate(Value = Value / (sqmi * 640))
  } else if (per != "" & per != "year") {
    map <- map |>
      mutate(Value = Value / !!sym(per)) #this should handle sqmi
  }
  
  return(list(map = map, subtitle = subtitle))
}
```

#bubble_map
```{r}
bubble_map <- function(map, state_map, level, max_bubble_size, palette, borders, region, scale_center, plusminus_labels, data_type, format_value) {
  
  low_fill_color <- midpoint_rgb(palette$mid_color, palette$low_color, 0.8)
  high_fill_color <- midpoint_rgb(palette$mid_color, palette$high_color, 0.8)
  
  map <- map |>
    mutate(Value = if_else(Value == 0 & is.na(scale_center), NA, Value),
           abs_value = abs(Value))
  min <- min(map$abs_value, na.rm = TRUE)
  max <- max(map$abs_value, na.rm = TRUE)
  min_bubble_size <- max_bubble_size * min / max
  
  if("Type" %in% data_type) {
    map <- map |> mutate(Type = as.factor(Type))
    if(min(map$Value, na.rm = T) < 0){
      stop("Negative Values in bubble_map, but Type is pre-specified.")
    }
  } else {
    if(is.na(scale_center)){
      map <- map |> 
        mutate(Type = ifelse(abs_value >= 0, "Has Value", "No Value"))
    } else {
      pos = plusminus_labels$pos
      neg = plusminus_labels$neg
      map <- map |> 
        mutate(Type = ifelse(Value >= scale_center, pos, neg))
    }
  }
  
    plot <- ggplot(data = map)
    
  if(level != "freefloating"){
    plot = plot +
      with_shadow(
        geom_sf(
          aes(fill = Type),
          color = ifelse(borders, "white", NA), linewidth = 0.1, show.legend = FALSE),
        x_offset = 3, y_offset = 3, sigma = 3, color = "grey70") +
      geom_point(
        data = map |> filter(abs_value > 0),
        aes(x = x, y = y, size = abs_value, color = Type),
        alpha = 0.5
      )
  } else if(level == "freefloating"){
    plot = plot +
      with_shadow(geom_sf(data = state_map, color = "black", fill = "white", linewidth = 0.5),
                 x_offset = 3, y_offset = 3, sigma = 3, color = "grey70") +
      geom_sf(
        data = map,
        aes(size = Value, color = Type),
        alpha = 0.5)
  }
    
  if(!is.na(region)){
    plot <- plot +
      geom_sf(data = region, fill = palette$highlight_color, color = "white")
  }
    
  breaks = compute_bubble_breaks(map$abs_value)
  break_labels = format_value(breaks)
    
  plot <- plot +
    scale_size_continuous(
      range = c(min_bubble_size, max_bubble_size),
      name = "",
      breaks = breaks,
      labels = break_labels
    ) 
    
  if (!is.null(state_map) & level != "freefloating") {
    plot <- plot +
      geom_sf(data = state_map, color = "black", fill = NA, linewidth = 0.5)
  }

  if("Type" %in% data_type) {
    # When Type column is provided by user
    type_levels <- levels(map$Type)
    
    type_colors = type_colors(length(type_levels))
    
    plot <- plot +
      scale_fill_manual(
        values = setNames(type_colors, type_levels),
        na.value = palette$na_color
      ) +
      scale_color_manual(
        values = setNames(type_colors, type_levels),
        na.translate = FALSE
      ) +
      guides(
        color = guide_legend(override.aes = list(size = max_bubble_size * 0.5)),
        size = guide_legend(override.aes = list(color = palette$mid_color))
      )
    
  } else if(is.na(scale_center)) {
    plot <- plot + 
      scale_fill_manual(
        values = c("Has Value" = high_fill_color, "No Value" = palette$na_color),
        na.value = palette$na_color
      ) +
      scale_color_manual(
        values = c("Has Value" = palette$high_color), 
        na.translate = FALSE
      ) +
      guides(color = "none", size = guide_legend(override.aes = list(color = palette$high_color)))
  } else {
    max_break <- max(compute_bubble_breaks(map$Value))
    max_value <- max(map$Value, na.rm = TRUE)
    legend_bubble_size <- max_bubble_size * sqrt(max_break / max_value)
    
    plot <- plot +
      scale_fill_manual(
        values = c(setNames(high_fill_color, plusminus_labels$pos), 
                   setNames(low_fill_color, plusminus_labels$neg)),
        na.value = palette$na_color
      ) +
      scale_color_manual(
        values = c(setNames(palette$high_color, plusminus_labels$pos),
                      setNames(palette$low_color, plusminus_labels$neg)), 
        na.translate = FALSE
      ) +
      guides(color = guide_legend(override.aes = list(size = legend_bubble_size)))
  }
   
  return(plot)
}
```

#choropleth_map
```{r}
choropleth_map <- function(map, state_map, level, breaks, labels_manual, palette, borders, region, scale_center, logratio, show_endpoints, na_label, max_bubble_size, data_type, increment, dollar, unit, format_value, format_value_no_unit) {
  
  if ("Type" %in% data_type) {
    map <- map %>% mutate(Type = as.factor(Type))
    type_levels <- levels(map$Type)
    
    type_colors = type_colors(length(type_levels))
    
    bin_palette <- setNames(type_colors, type_levels)
    formatted_labels <- type_levels
    
  } else {
    if (!is.na(breaks[1])) {
      if (!is.na(scale_center)) {
        breaks <- c(-abs(breaks), abs(breaks))
        breaks <- unique(breaks)
        breaks <- sort(breaks)
        breaks <- breaks + scale_center
        
        if(logratio){
          if(scale_center != 0){
            cat("Warning: scale center not at 0 makes no sense for log ratio.\n")
          }
          breaks = exp(breaks)
          map <- map |>
            mutate(Value = exp(Value))
        }
      }
      
      breaks = breaks[breaks < max(map$Value, na.rm = TRUE)]
      breaks = breaks[breaks > min(map$Value, na.rm = TRUE)]
      breaks <- c(round_to_sigfigs(min(map$Value, na.rm = TRUE), 2, "floor"),
                  breaks,
                  round_to_sigfigs(max(map$Value, na.rm = TRUE), 2, "ceiling"))
      
      breaks <- sort(breaks)
      num_breaks = length(breaks)
      
    } else {
      num_data_points = map |>
        filter(!is.na(Value), Value != 0) |>
        nrow()
      num_breaks = if_else(num_data_points > 20, 5, 4)
      breaks = compute_breaks(map$Value, num_breaks) #previously did 6 breaks but that is too many I think
    }
    
    if(is.na(scale_center)){
      breaks = remove_empty_breaks(map, breaks)
      if(num_breaks - length(breaks) > 0){
        num_breaks = num_breaks + (num_breaks - length(breaks)) #add number of removed breaks
        breaks = compute_breaks(map$Value, num_breaks)
        breaks = remove_empty_breaks(map, breaks)
      }
    }
    
    # if (is.na(labels_manual[1])) {
    #   formatted_labels <- paste0(dollar,
    #                            sapply(head(breaks, -1), shorten),
    #                            " to ",
    #                            dollar,
    #                            sapply(breaks[-1], shorten),
    #                            unit)
    #   if (!show_endpoints) {
    #     formatted_labels[length(formatted_labels)] <- paste0(">",str_remove(formatted_labels[length(formatted_labels)], " to .*"), unit)
    #     formatted_labels[1] <- paste0("<",str_remove(formatted_labels[1], ".* to "))
    #   }
    # } else {
    #   formatted_labels <- labels_manual
    # }
  if (is.na(labels_manual[1])) {
    #increment argument (0 by default)
    
    if (increment != 1 && all(map |> filter(!is.na(Value)) |> pull(Value) %% 1 == 0)) {
  cat("Data appears to be discrete. Recommended to set increment to 1.\n")
    }
    
  lower_breaks <- head(breaks, -1)
  upper_breaks <- breaks[-1]
  if (!show_endpoints) {
    first_label <- paste0(if_else(increment == 0, "<", "≤"), format_value(upper_breaks[1]))
    middle_labels <- paste0(format_value_no_unit(lower_breaks[-1] + increment), " to ", 
                             format_value(upper_breaks[-1]))
      formatted_labels <- c(first_label, middle_labels)
      formatted_labels[length(formatted_labels)] <- paste0(if_else(increment == 0, ">", "≥"), format_value(lower_breaks[length(lower_breaks)] + increment))
    
  } else {
    # If showing endpoints, use exact values without increment adjustment
    formatted_labels <- paste0(format_value_no_unit(lower_breaks), " to ", 
                             format_value(upper_breaks))
  }
} else {
  formatted_labels <- labels_manual
}
    
    map <- map |>
      mutate(Type = cut(
        Value,
        breaks = breaks,
        include.lowest = TRUE,
        labels = formatted_labels
      ))
    
    if(!is.na(scale_center)){
      low_palette <- seq_gradient_pal(palette$low_color, palette$mid_color)(seq(0, 1, length.out = length(breaks)/2))
      high_palette <- seq_gradient_pal(palette$mid_color, palette$high_color)(seq(0, 1, length.out = length(breaks)/2))
      bin_palette <- c(low_palette[-length(low_palette)], high_palette)
    } else {
      bin_palette <- seq_gradient_pal(palette$mid_color, palette$high_color)(seq(0, 1, length.out = length(breaks) - 1))
    }
  }
  
  plot <- ggplot(data = map)
  
  if(level == "freefloating") {
    if("Value" %in% data_type){
      if(is.na(scale_center)){
    map <- map |>
      arrange(!is.na(Value), Value)
    } else {
    map <- map |>
      arrange(!is.na(Value), abs(Value - scale_center))
      }
    }
    
    plot = plot + 
      with_shadow(
        geom_sf(data = state_map, color = "black", fill = "white", linewidth = 0.5),
        x_offset = 3, y_offset = 3, sigma = 3, color = "grey70"
      ) + geom_sf(
        data = map,
        aes(color = Type),
        size = max_bubble_size,
        alpha = 1) +
      scale_color_manual(
        values = bin_palette,
        na.value = palette$na_color,
        na.translate = TRUE,
        labels = c(formatted_labels, na_label)
      ) + guides(color = guide_legend(override.aes = list(size = 10),
                                      nrow = ceiling(length(breaks)/3)))
  } else {
    plot = plot + 
      with_shadow(
        geom_sf(aes(fill = Type), color = ifelse(borders, "white", NA), linewidth = 0.1),
        x_offset = 3, y_offset = 3, sigma = 3, color = "grey70"
      ) +
      scale_fill_manual(
        values = bin_palette,
        na.value = palette$na_color,
        na.translate = TRUE,
        labels = c(formatted_labels, na_label)
      )
  }
  
    if(!is.null(state_map) & level != "freefloating"){
        plot <- plot +
      geom_sf(data = state_map, color = "black", fill = NA, linewidth = if_else(level == "state", 1, 0.5)) #can't seem to make borders bold no matter how high I make the size
    }
  
  if(level == "state"){
    
    label_to_color <- tibble(Type = formatted_labels, bin_color = bin_palette)
    
    map <- map %>%
      left_join(label_to_color, by = "Type") %>%
      mutate(
        bin_color = replace_na(bin_color, palette$na_color),
        brightness = map_dbl(bin_color,  ~ calculate_brightness(.x)),
        text_color = if_else(brightness > 0.5, palette$text_color, "white")
      )
    
  plot = add_state_labels(plot, map, palette, dollar, unit) #dynamically set text color based on color of corresponding state (for states that don't have external label)
  }
  
  if(!is.na(region)){
    plot <- plot +
      geom_sf(
        data = region,
        fill = palette$highlight_color,
        color = "white"
      )
    }
  return(list(plot = plot, breaks = breaks))
}
```

#add_state_labels
```{r}
add_state_labels <- function(plot, map, palette, dollar, unit){
      #yes this is a mess but it works
  
  adjustments <- tibble( #these adjustments are needed for labels but aren't good bubble locations
  abbr = c("NH", "MA", "CT", "NJ","MD", "RI", "DE", "IN", "VT", "DC", "NY", "KY", "LA"), # Indiana adjustment is just so it doesn't overlap with Illinois for long labels
  x_adj = c(-10000, 70000, -35000, 10000, 25000, 0, 0, 5000, -20000, 460000, 20000, 30000, 0),
  y_adj = c(120000, -20000, -20000, -10000, -70000, 10000, -10000, 35000, 30000, -350000, 0, -10000, -20000)
)
  
  repels <- tibble(
    abbr = c("DE", "HI", "PR", "RI", "VT", "NJ", "CT", "NH", "MA", "MD"),
    x_nudge = c(100, 100, 100, 100, -100, 100, 100, -100, 100, 100),
    y_nudge = c(-50, -100, -100, -50, 100, -100, -50, 100, 100, -100),
    box_padding = c(1, 1, 1, 0.75, 1, 1, 1, 1, 1, 2)
  )
    if(unit == "%"){
      format_value = append_unit(dollar, unit)
      percent = "%"
    } else {
      format_value = append_unit(dollar, "")
      percent = ""
    }
    
map <- map |>
  left_join(adjustments, by = "abbr") |>
  mutate(
    x = coalesce(x + x_adj, x),
    y = coalesce(y + y_adj, y)
  ) |>
  select(-x_adj, -y_adj) |>
  mutate(label = format_value(Value),
         label = case_when(Value < 0.01 & Value > 0 ~ paste0("<", dollar, "0.01", percent), 
                           Value > -0.01 & Value < 0 ~ paste0(">-", dollar, "0.01", percent), #this will look kind of weird but idk what else to do to avoid signif making super long labels for very small numbers
                           T ~ label))
wv = map |> filter(abbr == "WV")
wv_label_length = nchar(wv$label)
if(wv_label_length > 4){
  map <- map|>
    filter(abbr != "WV")
  plot <- plot +
    geom_text(
        data = wv,
        aes(x = x, y = y, label = label, color = text_color),
        size = 4,
        fontface = "bold",
        angle = 45
      )
}

plot <- plot + 
      geom_text(data = map %>% filter(!(abbr %in% c("DC", repels$abbr))), 
         aes(x = x, y = y, label = label, color = text_color), 
         size = 4, 
         fontface = "bold") +
      scale_color_identity()

for (i in 1:nrow(adjustments)) {
  row <- repels[i, ]
  
  plot <- plot +
    geom_text_repel(
      data = map %>% filter(abbr == row$abbr),
      aes(x = x, y = y, label = label),
      nudge_x = row$x_nudge,
      nudge_y = row$y_nudge,
      size = 4,
      fontface = "bold",
      color = palette$text_color,
      box.padding = row$box_padding,
      segment.size = 0.8) #if I did it all in one call the repels would repel each other which is a huge mess
}

  # geom_text_repel(data = map %>% filter(abbr %in% c("DE", "HI", "PR")),
  #                          aes(x = x, y = y, label = label),
  #                          box.padding = 1, size = 4, fontface = "bold",color = palette$text_color, nudge_x = 100, nudge_y = -100) +
  #       geom_text_repel(data = map %>% filter(abbr == "RI"),
  #                          aes(x = x, y = y, label = label),
  #                          box.padding = 0.75, size = 4, fontface = "bold",color = palette$text_color, nudge_x = 100, nudge_y = -50) +
  #       geom_text_repel(data = map %>% filter(abbr == "VT"),
  #                          aes(x = x, y = y, label = label),
  #                          box.padding = 1, size = 4, fontface = "bold",color = palette$text_color, nudge_x = -100, nudge_y = 100) +
  #   geom_text_repel(data = map %>% filter(abbr == "NJ"),
  #                          aes(x = x, y = y, label = label),
  #                          box.padding = 1, size = 4, fontface = "bold",color = palette$text_color, nudge_x = 100, nudge_y = -100) +
  #       geom_text_repel(data = map %>% filter(abbr == "CT"),
  #                          aes(x = x, y = y, label = label),
  #                          box.padding = 1, size = 4, fontface = "bold",color = palette$text_color, nudge_x = 100, nudge_y = -50) +
  #       geom_text_repel(data = map %>% filter(abbr == "NH"),
  #                          aes(x = x, y = y, label = label),
  #                          box.padding = 1, size = 4, fontface = "bold",color = palette$text_color, nudge_x = -100, nudge_y = 100) +
  #       geom_text_repel(data = map %>% filter(abbr == "MA"),
  #                          aes(x = x, y = y, label = label),
  #                          box.padding = 1, size = 4, fontface = "bold",color = palette$text_color, nudge_x = 100, nudge_y = 100) +
  #       geom_text_repel(data = map %>% filter(abbr == "MD"),
  #                          aes(x = x, y = y, label = label),
  #                          box.padding = 2, size = 4, fontface = "bold",color = palette$text_color, nudge_x = 100, nudge_y = -100)
      
dc_row <- map |> filter(fips == "11", name == "District of Columbia")
  if (nrow(dc_row) == 1) {
    dc_row <- dc_row %>%
      mutate(label = paste0("DC: ", label))
    
  plot <- plot +
    geom_label(
      data = dc_row,
      aes(x = x, y = y, label = label),
      size = 4,
      fontface = "bold",
      fill = dc_row$bin_color,
      color = dc_row$text_color,
      label.size = 1 #state border thickness
    )
  }
      
      return(plot)
}
```

#merge_by_MSA
```{r}
merge_by_MSA <- function(county_map, region_fips){
   if(!exists("MSAs")){
    stop("Read in MSAs_crosswalk.csv as MSAs.")
  }
  if("Type" %in% colnames(county_map)) {
    stop("Merging categorical variable (Type) by MSA is not implemented.")
  }
  map <- county_map |>
      left_join(MSAs, by = "fips") |>
        mutate(metro_name = if_else(is.na(metro_name), name, metro_name),
        metro_name = if_else(str_detect(county, "Ag District"), county, metro_name) #Although I won't really be using this option for Ag Maps, this still seems like good practice
        )
    if(!is.na(region_fips)[1]){
      map <- map |>
        group_by(metro_name) |>
        mutate(num_counties = n())|> #if region_fips overlaps with MSAs, we don't merge that MSA
        filter(!(fips %in% region_fips)) |> #so that partially overlapping MSAs have the right populations
      mutate(metro_name = if_else(num_counties == n(), metro_name, name)) |> #drop CBSA Title/name for counties removed because they are in region_fips)
      ungroup()
    }
  
  #there may be a better way to do this
      aggregate_cols = setdiff(colnames(map), c("fips", "county", "abbr", "state", "x", "y", "name", "geometry", "cbsa_code", "metro_name")) #this only works because I remove all columns but fips and Value from the data fed into map(), but in the future, I may want to allow data to have other columns that do other things, so this isn't best practice
      
      map <- map |>
      group_by(metro_name, cbsa_code) |> #don't really need to be grouping by CBSA code here
      summarize(
        geometry = st_union(geometry),
        #across(contains("pop"), ~sum(.x)),
        #cutoff = sum(cutoff, na.rm = T), #cutoff is almost always something that can be aggregated
        across(all_of(aggregate_cols), ~sum(.x, na.rm = T))
        ) |>
      ungroup() |>
        mutate(Value = if_else(Value == 0, NA, Value))

coords <- st_coordinates(st_centroid(map))
map <- map |>
  mutate(x = coords[, 1],
         y = coords[, 2],
         name = metro_name)

return(map)
}
```