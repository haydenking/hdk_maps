---
title: "Map"
format: html
editor: source
---
```{r}
library(dplyr)
library(stringr)
library(readxl)
library(scales)
library(ggplot2)
library(sf)
library(ggfx)
library(ggrepel)
library(grid)
library(colorspace)
library(showtext)
library(sysfonts)
library(glue)
library(moments) #for skewness and kurtosis functions
library(cowplot) #for ggdraw

# font_add_google(name = "Nunito", family = "nunito") #extra bold looking font for state labels but it didn't work for some reason
font_add_google(name = "Lekton", family = "lekton")
showtext_auto()
#TO DO:
#map with per capita shading and bubbles/labels for absolute count
#aggregate county data by state and then use state map options > merge_by_state
```

```{r}
#after writing 1000+ loc I found out much of this functionality is already built :/
#But building off of these functions wouldn't allow me to do all the things I want to do so I will keep building on this
# vignette("usmap1", package = "usmap") # 1. Introduction
# vignette("usmap2", package = "usmap") # 2. Mapping the US
# vignette("usmap3", package = "usmap") # 3. Advanced Mapping
```


###map
```{r}
#put error handling in separate function?
#add good documentation
#add NYC inset for county-level map (both choropleth and bubble)
map <- function(data, map, state_map = NULL, title, source, font_size = NA, years = NA, bubbles = T, unit = "", per = "", max_bubble_size = NA, continental = F, borders = F, palette = list(), inset_cutoff = -Inf, cutoff_column = "Value", breaks = NA, na_to_0 = F, caption_manual = "", labels_manual = NA, inset_style = "top", subtitle = NA, region_fips = NA, merge_MSAs = F, scale_center = NA, scale_factor = 1, logratio = F, dpi = 300, show_endpoints = F, hide_values = F, tag = T, plusminus_labels = list(pos = "Positive", neg = "Negative"), inset_labels = list(top = "Top /n/", bottom = "Bottom /n/"), obs_units = "auto", na_label = "No Data", inset_box = T, v_adj = 0, increment = 0, city_insets = F) {
  
  palette = set_palette(palette)
  
  #Maps go in map folder, sub-folders named by source
  graphicspath = paste0("Maps/", source, "/")
  if(!dir.exists(graphicspath)){
    #prompt user to create folder
    createfolder = ""
    while(!createfolder %in% c("Y", "N")){
      createfolder = readline(prompt = paste0("Create folder '", source ,"'?[Y/N]\n"))
      createfolder <- toupper(createfolder) # So it isn't case sensitive
      if(createfolder == "Y"){
        dir.create(graphicspath, recursive = T) #recursive = T means that it will create the Maps folder too if it is missing
      } else if(createfolder == "N"){
        graphicspath = ""
        cat("Outputting map to working directory.\n")
      }
    }
  }
  
  level = detect_level(data, map)
  if(is.na(level)) {
    stop("Data level not recognized.")
  }

  cat("Level: ", level, "\n")
  
  data_type = detect_data_type(data)
  
  if(is.na(scale_center) & "Value" %in% data_type){
    if(min(data$Value, na.rm = T) < 0){
      cat("Warning: negative Values in data\n")
    }
  }
  if("Value" %in% data_type) {
    data <- data |>
      mutate(Value = Value * scale_factor) #for scaling (ex. scale_factor = 100000 for rate per 100000)
  }
  
  if(logratio){ #log ratio: use with migration type = "net", supply breaks as log of the positive ratios you want as breaks ex. c(log(1.1), log(1.3), log(1.5))
    per = "" #anything else would be silly
    unit = ":1"
  }
  
caption = make_caption(source, years, caption_manual) #might want to overhaul how this works
  
#considering removing this, I could just handle before passing the data into the mapping function
  if (per == "capita" & length(years) > 1 | per == "year") {
    num_years_ct = length(years[years < 2022]) #we don't have post-2021 data for CT due to the switch to planning regions, but I should write this better for post-2021 maps, but that is difficult without requiring that the data argument be un-aggregated by year
    num_years_notct = length(years)
    data <- data |>
      mutate(num_years = if_else(substr(fips, 1, 2) == "09" & level != "state", num_years_ct, num_years_notct), #CT
        Value = Value / num_years
      )
    subtitle <- if_else(is.na(subtitle) & per == "year", "Rate per year", subtitle)
  }
  
  if (!is.na(region_fips)[1]) {
      region = map |>
        filter(fips %in% region_fips) |>
        st_union()
  } else{
    region = NA
  }
  keep_cols = c("fips", data_type, cutoff_column, "geometry")
  if(level %in% c("freefloating", "MSA")){
    keep_cols = c(keep_cols, "name", "abbr")
  }
  data <- keep_columns(data, keep_cols)
  
  if(level == "MSA"){ #this option is for if data are already merged by MSA, otherwise county_map is supplied for map and merge_MSAs is true
    map = map |> #for MSA map we need to join by name because of non-metro counties
      left_join(data, by = join_by(metro_name == name)) |>
      rename(name = metro_name) #streamline this later
  } else if(level == "freefloating"){
    map = data #this should have Value and/or Type, geometry, name, abbr
  } else {
    map <- map |>
      left_join(data, by = "fips")
  }
  
  for(col in data_type){
    if(all(is.na(map[[col]]))){
      stop(paste0(col, "  is all NAs. Likely wrong map supplied. \n"))
    }
  }
  
    if("Value" %in% data_type){
    map <- map |>
      mutate(cutoff = !!sym(cutoff_column))
    }
  if(merge_MSAs){
    if("Type" %in% data_type){
      stop("Categorical data can't be merged by MSA.")
    } else if(level == "county"){ #merge_by_MSA merges a county_map by MSA
      map = merge_by_MSA(map, region_fips)
      level = "MSA"
    } else if(level == "MSA"){
      cat("Map merged by MSA already supplied, ignoring Merge_MSAs argument.")
    } else {
      stop("Only county level can be merged by MSA.")
    }
  }
  
  if (na_to_0 & "Value" %in% data_type) {
    map <- map |>
      mutate(Value = replace_na(Value, 0))
  } 

  dollar <- ""
  if (str_detect(unit, "\\$")) {
    dollar <- "$"
    unit <- str_remove(unit, "\\$")
  } else if (unit == "%") {
    map <- map |>
      mutate(Value = 100 * Value)
  } else if (!str_detect(unit, "$[/:]")) {#ratios and rates don't have the space before
    unit <- paste0(" ", unit)
  }
  
    if(per %in% c("capita", "capita_total", "year")){ #use capita_total to divide by population over a period of time but not year (ex. for cumulative % population changes over multiple years)
      if(is.na(years)[1]){
        stop("Specify which years the data are for.")
      }
      pop_cols <- paste0("pop", substr(years, 3, 4))
        map <- map %>%
          mutate(avg_pop = rowMeans(select(., all_of(pop_cols)), na.rm = TRUE)) %>%
          mutate(pop = coalesce(avg_pop, pop))
    }
  if("Value" %in% data_type){
  per_capita_result <- handle_per(map, source, per, subtitle, scale_factor)
  map <- per_capita_result$map
  subtitle <- per_capita_result$subtitle
  } else {
  inset_style = "hidden"
  }
  
  #vectorized string formatter
  format_value <- append_unit(dollar, unit)
  format_value_no_unit <- append_unit(dollar, "")
  
  if (inset_style == "hidden") {
    inset_text <- ""
  } else{ 
    obs_units = case_when(obs_units != "auto" ~ obs_units,
                      level == "county" ~ "Counties",
                      level == "puma" ~ "PUMAs",
                      level == "MSA" ~ "Counties/MSAs",
                      level == "state" ~ "States",
                      level == "ZIP" ~ "ZIP Codes",
                      T ~ "")
    if (inset_style %in% c("top", "bottom")) {
    inset_text <- create_inset(map, level, inset_style, 10, inset_cutoff, cutoff_column, logratio, scale_center, hide_values, inset_labels, obs_units, format_value)
  } else if (inset_style == "split") {
    top <- create_inset(map, level, "top", 5, inset_cutoff, cutoff_column, logratio, scale_center, hide_values, inset_labels, obs_units, format_value)
    bottom <- create_inset(map, level, "bottom", 5, inset_cutoff, cutoff_column, logratio, scale_center, hide_values, inset_labels, obs_units, format_value)
    inset_text = paste0(top, "\n",bottom)
    }
  }
  drop_regions = c("GU", "VI", "AS", "MP")
  if(abbr %in% colnames(map)) {
    pr = map |> filter(substr(fips, 1, 2) == "72")
  } else {
    pr = map |> filter(abbr == "PR")
  }
  
  if(all(is.na(pr$Value))) {
    drops_regions = c(drop_regions, "PR")
  }

  if (continental) { #filter out AK, HI, and PR after inset
    if("abbr" %in% colnames(map)) {
      drop_regions = c(drop_regions, "AK", "HI", "PR")
    } else{
      for(abbr in drop_regions){
        #this won't work for ZIP-level maps
        map <- map |>
          filter(!str_detect(name, paste0(", ", abbr, "$")))
      }
    }
  state_map <- state_map |>
    filter(!abbr %in% c("AK", "HI", "PR"))
    }
  if("abbr" %in% colnames(map)){
  map <- map |>
    filter(!abbr %in% drop_regions) 
  }
  
  map <- map |>
    filter(!st_is_empty(geometry))
  
  if (bubbles) {
    if(is.na(max_bubble_size)){
    max_bubble_size = auto_mbs(map)
  }
    plot <- bubble_map(map, state_map, level, max_bubble_size, palette, borders, region, scale_center, plusminus_labels, data_type, format_value)
  } else{
    if(is.na(max_bubble_size) & level == "freefloating"){
    max_bubble_size = min(2.5, max(1.5,10/log(nrow(map))))
    }
    if(city_insets){
      graphicsparams = list(
        "title" = title,
        "graphicspath" = graphicspath,
        "dpi" = dpi #could just have it fixed at 300
      )
    } else {
      graphicsparams = NULL
    }
    choropleth <- choropleth_map(map, state_map, level, breaks, labels_manual, palette, borders, region, scale_center, logratio, show_endpoints, na_label, max_bubble_size, data_type, increment, dollar, unit, format_value, format_value_no_unit, city_insets, graphicsparams)
    plot = choropleth$plot
    breaks = choropleth$breaks
  }
  
  plot <- add_theme(plot, title, palette, subtitle, font_size, caption, inset_text, breaks, bubbles, max_bubble_size, continental, tag, level, inset_box, v_adj)
  
  filepath = paste0(graphicspath, str_remove_all(title, "[ '()<>%]"), source, "_", level, ".jpg")
  showtext_opts(dpi = dpi)
  ggsave(filename = filepath, plot = plot, dpi = dpi, width = 10, height = 10) #set dpi to 100 for a cool retro look
  system2("open", filepath)
}
```

#helper functions
```{r}
keep_columns <- function(df, cols_to_keep) { #because select() doesn't work if you give it columns that aren't in the data
  existing_cols <- intersect(cols_to_keep, colnames(df))
  return(df[, existing_cols, drop = FALSE])
}
auto_mbs = function(map){
  map <- map |>
    mutate(abs_value = abs(Value))
  max = max(map$abs_value, na.rm = T)
  bubble <- map |>
    select(abs_value) |>
    mutate(normalized_bubble_size = abs_value / max,
           normalized_bubble_size = replace_na(normalized_bubble_size, 0))
  inflation_factor = 3000 / sum(bubble$normalized_bubble_size) #3000 was arrived at by trial and error, and doesn't work well for maps where the data is all clustered in one area
  max_bubble_size = sqrt(max(bubble$normalized_bubble_size) * inflation_factor) #bubble size is in terms of radius not area
  cat("Auto max bubble size: ", max_bubble_size, "\n")
  return(max_bubble_size)
}
#computes midpoint color
midpoint_rgb <- function(color1, color2, weight1) {
  if(weight1 < 0 | weight1 > 1){
    stop("weight1 is the weighting on the first color and must be between 0 and 1.\n")
  }
    col1 <- col2rgb(color1)
    col2 <- col2rgb(color2)
    mid_rgb <- weight1 * col1 + (1-weight1) * col2  # Biased the mix towards the mid_color so you can see the bubbles better
    rgb(mid_rgb[1], mid_rgb[2], mid_rgb[3], maxColorValue = 255)
}
calculate_brightness <- function(color) {
  rgb_values <- col2rgb(color) / 255  # Normalize RGB values to [0,1]
  return(0.299 * rgb_values[1] + 0.587 * rgb_values[2] + 0.114 * rgb_values[3])  # Brightness formula
}
compute_bubble_breaks <- function(values) { # This is for finding good bubble sizes for the legend
  max_value <- max(values, na.rm = TRUE)
  min_value <- max(min(values , na.rm = TRUE),1)
  
  powers_of_10 <- 10^(ceiling(log10(min_value)):floor(log10(max_value)))
  
  if (max_value > 5 * max(powers_of_10)) {
    powers_of_10 <- c(powers_of_10, 5 * max(powers_of_10))
  } else if(max_value > 2 * max(powers_of_10)){
    powers_of_10 <- c(powers_of_10, 2 * max(powers_of_10))
  }
  
  breaks <- sort(unique(powers_of_10))
  if (length(breaks) > 3) {
    breaks <- tail(breaks, 3) # No more than 3 bubbles in legend
  }
  return(breaks)
}

# compute_breaks <- function(values, n_breaks){
#   values = sort(values)
#   if(length(values) > 10){
#     n = min(ceiling(length(values)/10), 10)
#     topn = values[1:n]
#     diffs = topn[1:n-1] - topn[2:n]
#     cut_values = values[1:(length(values) - which.max(diffs) + 1)]
#   }else {
#     cut_values = values
#   }
#   max_value <- max(cut_values, na.rm = TRUE)
#   min_value <- max(min(cut_values , na.rm = TRUE), 0.000001)
#   powers_of_10 <- 10^(floor(log10(min_value)):floor(log10(max_value)))
#   potential_breaks = c(powers_of_10, 2*powers_of_10, 5*powers_of_10)
#   potential_breaks = potential_breaks[potential_breaks < max_value] #take out breaks above max value
#   potential_breaks = potential_breaks[potential_breaks > min_value] #take out breaks below min value
#   #maybe something where if only one observation is in the top break, then drop it
#   breaks <- sort(unique(potential_breaks))
#   breaks = tail(breaks, n_breaks-1)
#   breaks = c(round_to_sigfigs(min(values), 2, "floor"),
#                   breaks,
#                   round_to_sigfigs(max(values), 2,"ceiling"))
#   cat("Auto breaks: ", breaks, "\n")
#   return(breaks)
# }

compute_breaks <- function(values, n_breaks = 5) {
  values <- sort(values[!is.na(values)])
  
  sk <- skewness(values)
  ku <- kurtosis(values)
  
  if (abs(sk) > 1) {
    # Highly skewed → log spacing
    cat("Break type: log-spaced (skewed data)\n")
    rng <- range(values)
    breaks <- exp(seq(log(rng[1] + 1e-6), log(rng[2]), length.out = n_breaks))
    
  } else if (abs(sk) <= 1 && ku > 2 && ku < 5) {
    # Normal-ish → mean ± SD spacing
    cat("Break type: mean ± SD (normal-ish data)\n")
    m <- mean(values); s <- sd(values)
    breaks <- seq(m - 2*s, m + 2*s, length.out = n_breaks)
    breaks <- pmax(min(values), pmin(max(values), breaks))
    
  } else {
    # Flat/uniform-ish → quantiles
    cat("Break type: quantile-based (uniform/heavy-tailed data)\n")
    breaks <- quantile(values, probs = seq(0, 1, length.out = n_breaks))
  }
  
  # Clean up endpoints with your function
  breaks[1] <- round_to_sigfigs(min(values), 2, "floor")
  breaks[length(breaks)] <- round_to_sigfigs(max(values), 2, "ceiling")
  
  breaks <- sort(unique(breaks))
  cat("Auto breaks: ", breaks, "\n")
  return(breaks)
}


remove_empty_breaks <- function(map, breaks){ #this code tends to cause issues. should rewrite 
  data <- map$Value
  
  # Always include the first break (minimum value)
  adjusted_breaks <- c(breaks[1])
  
  # Iterate through the breaks starting from the second break
  for (i in 2:(length(breaks) - 1)) {
    # Check if there are any values between the previous break and the current break
    if (any(data >= breaks[i - 1] & data < breaks[i], na.rm = TRUE)) {
      # if there are, keep the current break
      adjusted_breaks <- c(adjusted_breaks, breaks[i])
    }
  }
  
  # Always include the last break (maximum value)
  adjusted_breaks <- c(adjusted_breaks, breaks[length(breaks)])
  adjusted_breaks = unique(adjusted_breaks) #so that the last break doesn't end up in there twice
  
  return(adjusted_breaks)
}

# For nice-looking breakpoints for a choropleth legend (I usually hide endpoints now, but it's still good to have this functionality)
round_to_sigfigs <- function(value, sigfigs, method = c("floor", "ceiling")) {
  method <- match.arg(method)
  if (value == 0) return(0)
  
  # Calculate the scale factor based on the significant figures
  scale_factor <- 10^(floor(log10(abs(value))) - (sigfigs - 1))
  
  if (method == "floor") {
    return(floor(value / scale_factor) * scale_factor)
  } else if (method == "ceiling") {
    return(ceiling(value / scale_factor) * scale_factor)
  }
}

append_unit <- function(dollar, unit) {
  function(x) {
    sign <- ifelse(x < 0, "-", "")
    paste0(sign, dollar, shorten(abs(x)), unit)
  }
}

#vectorized it
shorten <- function(value) {
  sapply(value, function(v) {
    if (is.na(v)) return("")

    abs_val <- abs(v)

    # if (abs_val >= 1000 && abs_val < 10000) {
    #   return(comma_format()(round(v)))
    # }

    thresholds <- c(1e12, 1e9, 1e6, 1e3, 1)
    suffixes   <- c("t",   "b",  "m",  "k", "")

    for (i in seq_along(thresholds)) {
      if (abs_val >= thresholds[i]) {
        display_value <- v / thresholds[i]
        sigfigs = 3
        # sigfigs <- if (display_value >= 100) 3 else 2
        return(paste0(signif(display_value, sigfigs), suffixes[i]))
      }
    }

    return(as.character(signif(v, 2)))
  })
}

#Distinguishable colors for categorical maps
type_colors <- function(n_types){
    if(n_types < 4) {
      type_colors <- c( "#007f7f", "#0000ff", "#00ff00")[1:n_types]
    } else {
      type_colors <- viridis(n_types+1)[1:n_types] #so that the highest break isn't bright yellow
    }
  return(type_colors)
}

detect_level <- function(data, map) {
    case_when(
  "fips" %in% names(data) & all(nchar(data$fips) == 2) ~ "state",
  "fips" %in% names(data) & all(nchar(data$fips) == 5) ~ "county",
  "fips" %in% names(data) & all(nchar(data$fips) == 7) ~ "puma",
  "metro_name" %in% names(map) ~ "MSA",
  "zip_code" %in% names(data) ~ "ZIP",
  "geometry" %in% names(data) ~ "freefloating",
  TRUE ~ NA
)
}

make_caption <- function(source, years = NA, caption_manual = "") {
  year_range <- if (!is.na(years[1])) paste0(min(years), "-", max(years)) else NULL
  
  base_caption <- switch(source,
    "USDA"  = "Source: USDA Agriculture Census",
    "IRS"   = paste0("Source: ", year_range, " IRS Migration Data"),
    "ACS"   = "Source: ACS Migration Data",
    if (!is.null(year_range)) paste0("Years: ", year_range) else ""
  )
  
  # Ensure newline handling
  if (caption_manual != "" & base_caption != "") {
    paste0(caption_manual, "\n", base_caption)
  } else {
    paste0(caption_manual, base_caption)
  }
}

detect_data_type <- function(data) {
  if ("Type" %in% names(data) & "Value" %in% names(data)) return(c("Type", "Value"))
  if ("Value" %in% names(data)) return("Value")
  if ("Type" %in% names(data)) return("Type")
  stop("data must have Value and/or Type column.")
}
```

#set_palette
```{r}
#allow "midpoint" to be specified for mid_color to get true midpoint between high_color and low_color
set_palette <- function(user_palette) {
  default_palette <- list(
    "high_color" = "red", #forestgreen
    "mid_color" = "#FFE5B4",  # #FFE5B4 #ECE4D5 #ffda9a
    "low_color" = "blue", #  #CC5500
    "background_color" = "#E8DACC",# #f1e0cf
    "title_color" = "#363c45",
    "text_color" = "#363c45",
    "highlight_color" = "steelblue",
    "na_color" = "gray80"
  )
  return(modifyList(default_palette, user_palette)) #overwrites defaults
}
```

#create_inset
```{r}
#Exclude Puerto Rico? Sometimes yes sometimes no? For county maps I don't want it to be the entire top or bottom
create_inset <- function(map, level, style = c("top", "bottom"), n, inset_cutoff, cutoff_column, logratio, scale_center, hide_values, inset_labels, obs_units, format_value) {
  
  style <- match.arg(style)
  
  # if(level == "county"){
  #   map <- map |>
  #     mutate(name = case_when(fips == "57001" ~ "Overseas",
  #                           fips == "57003" ~ "Puerto Rico",
  #                           fips == "57005" ~ "Military Deployment",
  #                           fips == "57007" ~ "U.S. Virgin Islands",
  #                           T ~ name
  #                           ))
  # }
  inset_data <- map |>
    st_drop_geometry() |>
        filter(cutoff >= inset_cutoff,
           !is.na(Value),
           !is.na(name))
  
  # Taking out DC because people complained and PR because people will complain
  if(level == "state"){
    inset_data <- inset_data |>
      filter(!fips %in% c("11", "72"))  
  }

  if(logratio){
    inset_data <- inset_data |>
      mutate(Value = exp(Value))
  }
  if (style == "top") {
    inset_data <- inset_data |>
      arrange(desc(Value))
  } else {
    inset_data <- inset_data |>
      arrange(Value)
  }
 inset_data <- inset_data |>
    mutate(
      rank_value = min_rank(if (style == "top") desc(Value) else Value),
      rank = as.character(rank_value),
      rank = if_else(rank_value < 10, paste0(rank, ".   "), paste0(rank, ". "))
    )
  
  # Expand n if ties would push beyond requested number
  last_rank_value <- inset_data$rank_value[min(n, nrow(inset_data))]
  
  # Keep only top n (now including all ties at cutoff)
  inset_data <- inset_data |>
    filter(rank_value <= last_rank_value)
  if(nrow(inset_data) > n){
    message("Expanding inset to ", n, " observations due to ties.\n")
  }
  n = nrow(inset_data)
  
inset_data <- inset_data |>
  mutate(
    plus = case_when(is.na(scale_center) ~ "",
                     scale_center == 0 & Value > 0 ~ "+",
                     T ~ ""),
    label = if (hide_values) {
      paste0(rank, name)
    } else {
      paste0(rank, name, ": ", plus, format_value(Value))
    }
  )

  topbottom = if_else(style == "top", inset_labels$top, inset_labels$bottom)
    #use /n/ to insert n
  topbottom = str_replace(topbottom, "/n/",as.character(n)) #Turn "Top /n/" into "Top 10" or "Bottom /n/" into "Bottom 5"
  if(obs_units != ""){
    topbottom = if_else(str_detect(topbottom, " $"), topbottom , paste0(topbottom, " ")) # Make sure top/bottom ends in a space
  }
  
  title_line =  paste0(topbottom, obs_units, 
                      if_else(inset_cutoff > 0, paste0(" (min ", shorten(inset_cutoff), " ", cutoff_column, ")"), ""), 
                      ":\n")
  inset <- paste0(title_line, paste(inset_data$label, collapse = "\n"))
  
  return(inset)
}
```

#add_theme
```{r}
#legend takes up too much space when it has to do color and size, covers up caption
#having issues with high max_bubble_size (> ~30), but that may be unavoidable due to space constraints
add_theme <- function(plot, title, palette, subtitle, font_size, caption, inset_text, breaks, bubbles, max_bubble_size, continental, tag, level, inset_box, v_adj) {

  font = "Arial"

  title_height = 1.04

  if(is.na(font_size)){
    font_size = min(36*38/nchar(title), 36) #the plot is a bit more than 40 characters wide at font size 36, but at font size 36 I'd still want some breathing room so 36 characters is when I start reducing the font size (depends on the font you're using)
    #this was done using another font, I think 38 is better now
    cat("Auto font size: ", font_size,"\n")
  }
  
  negative_margin = -10
  relative_negative_margin = 0.012 #how far in the edge moves from the negative margin on the side (symmetrical)
  
  title_alignment = 0.5 #negative margin is equal on each side so title is centered
  subtitle_offset = 0.07*(font_size/36) # Vertical adjustment for subtitle
  #shift everything down for continental map
  continental_offset = if_else(continental, 0.155, 0) #trial and error for this, need to update it based on some changes I made but I never actually use this setting so I'm putting it off, was 0.127 for old alignment

  # For inset box
  inset_font_size = 11.5

  #use v_adj when freefloating map has messed up alignment to get caption and inset back to where they should be
  y_pos <- unit(-0.258 - continental_offset + v_adj, "npc") #bottom of panel, used for caption and inset
  x_box <- unit(if_else(level == "puma", 0.99, 0.8) - relative_negative_margin, "npc") #right edge of inset box
  #puma level maps need really wide insets


  plot <- plot +
    theme_minimal(base_family = font) +
    theme(
      legend.title = element_blank(),
      legend.text = element_text(size = 14, color = palette$text_color, face = "bold"),
      legend.position = "inside",
      legend.position.inside = c(relative_negative_margin, -0.02),
      legend.justification = c("left", "top"),
      legend.direction = "horizontal",
      legend.key.width = unit(if_else(bubbles, min(sqrt(max_bubble_size)/4, 0.75), 0.5), "cm"),
      legend.key.height = unit(0.5, "cm"),
      panel.grid = element_blank(),
      panel.background = element_rect(fill = palette$background_color, color = NA),
      plot.background = element_rect(fill = palette$background_color, color = NA),
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      legend.box.margin = margin(0, 0, 60, 0), #might need to adjust top margin
      plot.margin = margin(if_else(continental, -140, -80), negative_margin, 0, negative_margin)
    ) +
    annotation_custom(textGrob(
      title,
      gp = gpar(
        fontsize = font_size,
        fontface = "bold",
        col = palette$title_color, fontfamily = font
      ),
      x = unit(title_alignment, "npc"),
      y = unit(title_height, "npc"),
      hjust = 0.5
    )) +
    annotation_custom(textGrob(
      if_else(tag, "@hdk_maps", ""),
      gp = gpar(fontsize = 12, col = palette$title_color, fontface = "bold", fontfamily = "lekton"),
      x = unit(title_alignment, "npc"),
      y = unit(title_height - subtitle_offset - if_else(is.na(subtitle), 0, subtitle_offset/2), "npc"), #0.034
      hjust = 0.5
     )) +
    coord_sf(clip = "off", expand = T) + #expand = F
    annotation_custom(textGrob(
      caption,
      gp = gpar(fontsize = 10, col = palette$text_color, fontfamily = font),
      x = unit(relative_negative_margin, "npc"),
      y = y_pos - unit(0.01, "npc"),
      hjust = 0,
      vjust = 0
    ))
  
  # x_pos <- unit(if_else((level == "state" & !continental), 0.5, 0.32), "npc") #for non-right-aligned inset
  #left-aligned inset
  # if(inset_box & inset_text != "") {
  #       plot = plot +
  #   annotation_custom(
  #     roundrectGrob(
  #       x =  x_pos - unit(0.01, "npc"),
  #       y = y_pos - unit(0.01, "npc"),
  #       width = text_width + unit(0.02, "npc"),
  #       height = text_height + unit(0.02, "npc"),
  #       r = unit(0.03, "npc"), #0.1 is the most you can do without the corners bumping into the text but 0.03 looks better
  #       just = c("left", "bottom"),
  #       gp = gpar(fill = midpoint_rgb(palette$mid_color, palette$high_color, 0.7), col = palette$text_color, lwd = 3)
  #     ))
  # }
  #   plot = plot +
  #   annotation_custom(
  #   textGrob(
  #     inset_text,
  #     x = x_pos,
  #     y = y_pos,
  #     just = c("left", "bottom"),
  #     gp = gpar(
  #       fontsize = inset_font_size,
  #       fontface = "bold",
  #       col = palette$text_color,
  #       fontfamily = font)
  #     ))
  
    tg <- textGrob(
      inset_text,
      gp = gpar(
        fontsize = inset_font_size,
        fontface = "bold",
        fontfamily = font
      )
    )
    text_width  <- grobWidth(tg)
    text_height <- grobHeight(tg)
  
    padding <- unit(0.3, "cm")
  
    box_width  <- text_width + 2 * padding
    box_height <- text_height + 2 * padding
  
    box_x <- x_box - box_width / 2
  
  if (inset_box & inset_text != "") {
  plot <- plot +
    annotation_custom(
      roundrectGrob(
        x = box_x,
        y = y_pos,
        width = box_width,
        height = box_height,
        r = unit(0.03, "npc"),
        just = c("center", "bottom"),
        gp = gpar(
          fill = midpoint_rgb(palette$mid_color, palette$high_color, 0.7),
          col = palette$text_color,
          lwd = 3
        )
      )
    )
  }
    plot = plot +
      annotation_custom(
        textGrob(
          inset_text,
          x = x_box - box_width + padding,
          y = y_pos + padding,
          just = c("left", "bottom"),
          gp = gpar(
            fontsize = inset_font_size,
            fontface = "bold",
            col = palette$text_color,
            fontfamily = font
          )
        )
      )

  if (!is.na(subtitle)) {
    plot <- plot +
      annotation_custom(textGrob(
        subtitle,
        gp = gpar(fontsize = font_size/2, col = palette$title_color, fontface = "bold", fontfamily = font),
        x = unit(title_alignment, "npc"),
        y = unit(title_height - subtitle_offset, "npc"),
        hjust = 0.5
      ))
  }

  #didn't try very hard to make it work but it seems this kinda might not work if I put it in choropleth_map idk why
  if (!bubbles & level != "freefloating") {
    plot <- plot +
      theme(legend.key = element_rect(fill = NA, color = "black",  linewidth = 1.75))
  }

    #This works for center aligned text regardless of negative margins but adds white bars at the top and bottom
  #   p_final <- ggdraw() +
  # draw_plot(plot, 0, 0, 1, 1) +
  # draw_label(title,
  #            x = 0.5, y = 0.98,
  #            hjust = 0.5, vjust = 1,
  #            fontface = "bold",
  #            size = font_size,
  #            color = palette$title_color)
    
  return(plot)
}
```

#handle_per
```{r}
handle_per <- function(map, source, per, subtitle, scale_factor) {
  
  if (per %in% c("capita", "capita_total") ) {
      map <- map |> 
        mutate(Value = Value / avg_pop)
      if(scale_factor != 1){
        subtitle = paste0("Rate per ", shorten(scale_factor), if_else(per == "capita", " year", ""))
      }
    } else if (per == "acre") {
    map <- map |>
      mutate(Value = Value / (sqmi * 640))
  } else if (per != "" & per != "year") {
    map <- map |>
      mutate(Value = Value / !!sym(per)) #this should handle sqmi
  }
  
  return(list(map = map, subtitle = subtitle))
}
```

#bubble_map
```{r}
bubble_map <- function(map, state_map, level, max_bubble_size, palette, borders, region, scale_center, plusminus_labels, data_type, format_value) {
  
  low_fill_color <- midpoint_rgb(palette$mid_color, palette$low_color, 0.8)
  high_fill_color <- midpoint_rgb(palette$mid_color, palette$high_color, 0.8)
  
  map <- map |>
    mutate(Value = if_else(Value == 0 & is.na(scale_center), NA, Value),
           abs_value = abs(Value))
  min <- min(map$abs_value, na.rm = TRUE)
  max <- max(map$abs_value, na.rm = TRUE)
  min_bubble_size <- max_bubble_size * min / max
  
  if("Type" %in% data_type) {
    map <- map |> mutate(Type = as.factor(Type))
    if(min(map$Value, na.rm = T) < 0){
      stop("Negative Values in bubble_map, but Type is pre-specified.")
    }
  } else {
    if(is.na(scale_center)){
      map <- map |> 
        mutate(Type = ifelse(abs_value >= 0, "Has Value", "No Value"))
    } else {
      pos = plusminus_labels$pos
      neg = plusminus_labels$neg
      map <- map |> 
        mutate(Type = ifelse(Value >= scale_center, pos, neg))
    }
  }
  
    plot <- ggplot(data = map)
    
  if(level != "freefloating"){
    plot = plot +
      with_shadow(
        geom_sf(
          aes(fill = Type),
          color = ifelse(borders, "white", NA), linewidth = 0.1, show.legend = FALSE),
        x_offset = 3, y_offset = 3, sigma = 3, color = "grey70") +
      geom_point(
        data = map |> filter(abs_value > 0),
        aes(x = x, y = y, size = abs_value, color = Type),
        alpha = 0.5
      )
  } else if(level == "freefloating"){
    plot = plot +
      with_shadow(geom_sf(data = state_map, color = "black", fill = "white", linewidth = 0.5),
                 x_offset = 3, y_offset = 3, sigma = 3, color = "grey70") +
      geom_sf(
        data = map,
        aes(size = Value, color = Type),
        alpha = 0.5)
  }
    
  if(!is.na(region)){
    plot <- plot +
      geom_sf(data = region, fill = palette$highlight_color, color = "white")
  }
    
  breaks = compute_bubble_breaks(map$abs_value)
  break_labels = format_value(breaks)
    
  plot <- plot +
    scale_size_continuous(
      range = c(min_bubble_size, max_bubble_size),
      name = "",
      breaks = breaks,
      labels = break_labels
    ) 
    
  if (!is.null(state_map) & level != "freefloating") {
    plot <- plot +
      geom_sf(data = state_map, color = "black", fill = NA, linewidth = 0.5)
  }

  if("Type" %in% data_type) {
    # When Type column is provided by user
    type_levels <- levels(map$Type)
    
    type_colors = type_colors(length(type_levels))
    
    plot <- plot +
      scale_fill_manual(
        values = setNames(type_colors, type_levels),
        na.value = palette$na_color
      ) +
      scale_color_manual(
        values = setNames(type_colors, type_levels),
        na.translate = FALSE
      ) +
      guides(
        color = guide_legend(override.aes = list(size = max_bubble_size * 0.5)),
        size = guide_legend(override.aes = list(color = palette$mid_color))
      )
    
  } else if(is.na(scale_center)) {
    plot <- plot + 
      scale_fill_manual(
        values = c("Has Value" = high_fill_color, "No Value" = palette$na_color),
        na.value = palette$na_color
      ) +
      scale_color_manual(
        values = c("Has Value" = palette$high_color), 
        na.translate = FALSE
      ) +
      guides(color = "none", size = guide_legend(override.aes = list(color = palette$high_color)))
  } else {
    max_break <- max(compute_bubble_breaks(map$Value))
    max_value <- max(map$Value, na.rm = TRUE)
    legend_bubble_size <- max_bubble_size * sqrt(max_break / max_value)
    
    plot <- plot +
      scale_fill_manual(
        values = c(setNames(high_fill_color, plusminus_labels$pos), 
                   setNames(low_fill_color, plusminus_labels$neg)),
        na.value = palette$na_color
      ) +
      scale_color_manual(
        values = c(setNames(palette$high_color, plusminus_labels$pos),
                      setNames(palette$low_color, plusminus_labels$neg)), 
        na.translate = FALSE
      ) +
      guides(color = guide_legend(override.aes = list(size = legend_bubble_size)))
  }
   
  return(plot)
}
```

#choropleth_map
```{r}
#maybe for state level maps the coloring should be continuous because the labels give the exact values??
choropleth_map <- function(map, state_map, level, breaks, labels_manual, palette, borders, region, scale_center, logratio, show_endpoints, na_label, max_bubble_size, data_type, increment, dollar, unit, format_value, format_value_no_unit, city_insets, graphicsparams) {
  
  if ("Type" %in% data_type) {
    map <- map %>% mutate(Type = as.factor(Type))
    type_levels <- levels(map$Type)
    type_colors = type_colors(length(type_levels))
    bin_palette <- setNames(type_colors, type_levels)
    formatted_labels <- type_levels
  } else {
    vals <- map$Value
    vals <- vals[!is.na(vals)]
    
    # Handle scale centering
    if (!is.na(breaks[1]) && !is.na(scale_center)) {
      breaks <- c(-abs(breaks), abs(breaks)) + scale_center
      breaks <- sort(unique(breaks))
      if (logratio) {
        if (scale_center != 0) {
          warning("scale_center ≠ 0 makes no sense for log ratio, ignoring.\n")
          scale_center = 0
        }
        breaks <- exp(breaks)
        map <- map %>% mutate(Value = exp(Value))
        vals <- map$Value
      }
    }
    
    # If breaks not provided → compute automatically
    if (is.na(breaks[1])) {
      num_data_points <- length(vals)
      num_breaks <- ifelse(num_data_points > 20, 5, 4)
      breaks <- compute_breaks(vals, num_breaks)
    }
    
    # Ensure breaks cover the full range of data
    rng <- range(vals, na.rm = TRUE)
    breaks <- sort(unique(c(
      round_to_sigfigs(rng[1], 2, "floor"),
      breaks[breaks > rng[1] & breaks < rng[2]],
      round_to_sigfigs(rng[2], 2, "ceiling")
    )))
    
    # Remove empty breaks
    breaks <- remove_empty_breaks(map, breaks)
    
    if (length(breaks) < 3) {
      # Generate breaks if too few survived
      breaks <- compute_breaks(vals, 5)
      breaks <- remove_empty_breaks(map, breaks)
    }
    
    if (is.na(labels_manual[1])) {
      lower_breaks <- head(breaks, -1)
      upper_breaks <- breaks[-1]
  if (!show_endpoints) {
    first_label <- paste0(if_else(increment == 0, "<", "≤"), format_value(upper_breaks[1]))
    middle_labels <- paste0(format_value_no_unit(lower_breaks[-1] + increment), " to ", 
                             format_value(upper_breaks[-1]))
      formatted_labels <- c(first_label, middle_labels)
      formatted_labels[length(formatted_labels)] <- paste0(if_else(increment == 0, ">", "≥"), format_value(lower_breaks[length(lower_breaks)] + increment))
    
  } else {
    # If showing endpoints, use exact values without increment adjustment
    formatted_labels <- paste0(format_value_no_unit(lower_breaks), " to ", 
                             format_value(upper_breaks))
  }
} else {
      formatted_labels <- labels_manual
      expected_labels = length(breaks) - 1
      if (length(formatted_labels) != expected_labels) {
        stop(glue("Label count ({length(formatted_labels)}) does not match expected number of labels ({expected_labels})."))
      }
    }
    map <- map %>%
      mutate(Type = cut(Value,
                        breaks = breaks,
                        include.lowest = TRUE,
                        labels = formatted_labels))
    
    # Palette
    if (!is.na(scale_center)) {
      half <- length(breaks) / 2
      low_palette <- seq_gradient_pal(palette$low_color, palette$mid_color)(seq(0, 1, length.out = half))
      high_palette <- seq_gradient_pal(palette$mid_color, palette$high_color)(seq(0, 1, length.out = half))
      bin_palette <- c(low_palette[-length(low_palette)], high_palette)
    } else {
      bin_palette <- seq_gradient_pal(palette$mid_color, palette$high_color)(seq(0, 1, length.out = length(breaks) - 1))
    }
  }
    plot <- ggplot(data = map)
  
  if (level == "freefloating") {
    if ("Value" %in% data_type) {
      map <- if (is.na(scale_center)) arrange(map, !is.na(Value), Value)
             else arrange(map, !is.na(Value), abs(Value - scale_center))
    }
    
    plot = plot + 
      with_shadow(
        geom_sf(data = state_map, color = "black", fill = "white", linewidth = 0.5),
        x_offset = 3, y_offset = 3, sigma = 3, color = "grey70"
      ) + geom_sf(
        data = map,
        aes(color = Type),
        size = max_bubble_size,
        alpha = 1
      ) +
      scale_color_manual(
        values = bin_palette,
        na.value = palette$na_color,
        na.translate = TRUE,
        labels = c(formatted_labels, na_label)
      ) + guides(color = guide_legend(override.aes = list(size = 10),
                                      ncol = ceiling((length(breaks) - 1) / 6)))
  } else {
    plot = plot + 
      with_shadow(
        geom_sf(aes(fill = Type), color = ifelse(borders, "white", NA), linewidth = 0.3),
        x_offset = 3, y_offset = 3, sigma = 3, color = "grey70"
      ) +
      scale_fill_manual(
        values = bin_palette,
        na.value = palette$na_color,
        na.translate = TRUE,
        labels = c(formatted_labels, na_label)
      ) + guides(fill = guide_legend(ncol = ceiling((length(breaks) - 1) / 6))) #at most 6 rows in the legend
    }
  
  
  stateborders = case_when(level == "state" ~ 1,
                        level == "county" ~ 0.5,
                        level == "puma" ~ 0.5,
                        T ~ 0.1)
  
  if (!is.null(state_map) & level != "freefloating") {
    plot <- plot +
      geom_sf(data = state_map, color = "black", fill = NA, linewidth = stateborders)
  }
  
  if (level == "state") {
    label_to_color <- tibble(Type = formatted_labels, bin_color = bin_palette)
    
    map <- map %>%
      left_join(label_to_color, by = "Type") %>%
      mutate(
        bin_color = replace_na(bin_color, palette$na_color),
        brightness = map_dbl(bin_color, ~ calculate_brightness(.x)),
        text_color = if_else(brightness > 0.5, palette$text_color, "white")
      )
    
    plot = add_state_labels(plot, map, palette, dollar, unit, increment)
  }
  
  if (!is.na(region)) {
    plot <- plot +
      geom_sf(data = region, fill = palette$highlight_color, color = "white")
  }
  if(!level %in% c("county", "puma") & city_insets){
      cat("City insets only make sense for level == county, PUMA, or freefloating. Freefloating not implemented yet.\n")
      city_insets = F
    }
  
  if(city_insets) {
    
    map_3857 <- st_transform(map, 3857)

cities <- tibble::tribble(
  ~title,            ~lon,     ~lat,   ~zoom_km,
  "New York City",   -73.9,    40.75,   45,
  "Los Angeles",     -118,   33.9,   75,
  "Bay Area",        -122.15,   37.65,   70,
  "Chicago",         -87.8,    41.9,   50,
  "DC Area",         -77.0,    38.9,   50,
  "Boston",          -71.1,    42.4,   45,
  "Houston",         -95.4,    29.8,   60,
  "Dallas - Fort Worth", -97.0,   32.85,   65,
  "Phoenix",           -112.1,  33.5,   65
)
cities2 <- tibble::tribble(
  ~title,           ~lon,     ~lat,   ~zoom_km,
  "Atlanta",         -84.4,    33.8,   60,
  "Miami",           -80.2,    25.9,   40,
  "Philadelphia",      -75.2,   40.0,   50,
  "Detroit",           -83.1,   42.4,   50,
  "Minneapolis - St. Paul", -93.3, 44.9,  50,
  "San Diego",     -117.15,   32.86,   40,
  "Seattle",           -122.3,  47.6,   60,
  "Charlotte",     -80.8,    35.2,   45,
  "Denver",            -104.9,  39.7,   60
)
cities3 <- tibble::tribble(
  ~title,          ~lon,     ~lat,   ~zoom_km,
  "Cleveland",         -81.7,   41.5,   45,
  "San Antonio",   -98.5,    29.5,   50,
  "Austin",        -97.7,    30.3,   45,
  "St. Louis",         -90.3,   38.6,   50,
  "Portland",      -122.7,   45.5,   45,
  "Las Vegas",     -115.1,   36.2,   45,
  "Orlando",       -81.4,    28.5,   45,
  "Tampa Bay",     -82.5,    27.9,   45,
  "Sacramento",    -121.5,   38.6,   40
)
cities4 <- tibble::tribble(
  ~title,              ~lon,     ~lat,   ~zoom_km,
  "Indianapolis",      -86.15,   39.8,    45,
  "Columbus",          -83.0,    40.0,    45,
  "Nashville",         -86.8,    36.2,    45,
  "Kansas City",       -94.6,    39.1,    50,
  "Pittsburgh",        -80.0,    40.45,   40,
  "Salt Lake City",    -111.9,   40.75,   50,
  "Cincinnati",        -84.5,    39.15,    40,
  "Raleigh - Durham",  -78.8,    35.85,    55,
  "Milwaukee",         -87.95,    43.0,    35
)
#these might need to be fine tuned later

city_sets <- list(
  inset1 = cities,
  inset2 = cities2,
  inset3 = cities3,
  inset4 = cities4
)

create_map_inset <- function(data_3857, lon, lat, zoom_km, title) {
  # Create center point in lon/lat, then transform to 3857
  center_point <- st_sfc(st_point(c(lon, lat)), crs = 4326) %>%
    st_transform(3857)
  
  # Buffer in meters
  crop_box <- st_buffer(center_point, dist = zoom_km * 1000) %>% st_bbox()
  
  ggplot(data = data_3857) +
    geom_sf(aes(fill = Type), linewidth = 0.2, color = "gray80") + #very thin PUMA borders
    scale_fill_manual(
        values = bin_palette,
        na.value = palette$na_color,
        na.translate = TRUE,
        labels = c(formatted_labels, na_label)
      ) +
    coord_sf(
      crs = st_crs(3857),
      xlim = c(crop_box["xmin"], crop_box["xmax"]),
      ylim = c(crop_box["ymin"], crop_box["ymax"]),
      expand = FALSE
    ) +
    labs(title = title) +
    theme_void() +
    theme(
      panel.background = element_rect(fill = "white", color = NA), 
      # plot.background  = element_rect(fill = palette$background_color, color = NA),
      legend.position = "none",
      plot.title = element_text(hjust = 0.5, size = 9, color = palette$text_color, face = "bold"),
      panel.border = element_rect(color = "black", fill = NA, linewidth = 1)
    )
}

# Function to build an inset grid for a set of cities
build_inset_grid <- function(city_tbl, map_3857, palette, graphics_params, level, idx) {
  inset_list <- pmap(
    city_tbl,
    ~create_map_inset(map_3857, lon = ..2, lat = ..3, zoom_km = ..4, title = ..1)
  )
  
  grid <- ggdraw() +
    draw_plot(
      plot_grid(plotlist = inset_list, ncol = 3),
      0, 0, 1, 1
    ) +
    theme(plot.background = element_rect(fill = palette$background_color, color = NA))
  
  filepath <- paste0(
    graphics_params$graphicspath,
    str_remove_all(graphics_params$title, "[ '()<>%]"),
    "_", level, "_", idx, ".jpg"
  )
  
  ggsave(filename = filepath, plot = grid, 
         dpi = graphics_params$dpi, width = 10, height = 10)
  system2("open", filepath)
  
  return(filepath)
}

# Now loop over your city sets and build all grids
filepaths <- imap(city_sets, ~build_inset_grid(.x, map_3857, palette, graphicsparams, level, .y))
  }
  
  return(list(plot = plot, breaks = breaks))
}
```

#add_state_labels
```{r}
#doesn't work for Categorical data yet
add_state_labels <- function(plot, map, palette, dollar, unit, increment){
  font = "Nunito" #not sure if it's working, looks exactly the same as Arial
  font_size = 4 #this is as big as the font can be without indiana and florida running into the borders a significant amount (the bold border don't help)
  
  
    adjustments <- tibble( #these adjustments are needed for labels but aren't good bubble locations
  abbr = c("NH", "MA", "CT", "NJ","MD", "RI", "DE", "IN", "VT", "DC", "NY", "KY", "LA", "FL"), # Indiana adjustment is just so it doesn't overlap with Illinois for long labels
  x_adj = c(-10000, 70000, -35000, 10000, 25000, 0, 0, 5000, -20000, 460000, 20000, 30000, 0, 50000),
  y_adj = c(120000, -20000, -20000, -10000, -70000, 10000, -10000, 35000, 30000, -350000, 0, -10000, -20000, -120000)
)
  
  repels <- tibble(
    abbr = c("DE", "HI", "PR", "RI", "VT", "NJ", "CT", "NH", "MA", "MD"),
    x_nudge = c(100, -50, 100, 100, -100, 100, 100, -100, 100, 100),
    y_nudge = c(-50, -100, -100, -50, 100, -100, -50, 100, 100, -100),
    padding = c(1, 1.25, 1, 0.75, 1, 1, 1, 1, 1, 2)
  )
  
#   adjustments <- tibble( #these adjustments are needed for labels but aren't good bubble locations
#   abbr = c("MA", "NH", "CT", "NJ", "MD", "RI", "DE", "IN", "VT", "DC", "NY", "KY", "LA", "FL"), # Indiana adjustment is just so it doesn't overlap with Illinois for long labels
#   x_adj = c(65000, -12000, -50000, 10000, 25000, 0, 0, 5000, -20000, 400000, 20000, 30000, 0, 50000),
#   y_adj = c(-25000, 120000, -20000, -10000, -70000, -10000, -10000, 35000, 30000, -460000, 0, -10000, -20000, -120000)
# )
#   #MA was -35000, 8000 for not using repel text
#   
#   repels <- tibble(
#     abbr = c("DE", "HI", "RI", "VT", "NJ", "CT", "NH", "MD", "PR"),
#     x_nudge = c(100, 100, 500, -100, 100, 50, -100, 100, 0),
#     y_nudge = c(-50, -100, -50, 100, -100, -100, 100, -100, -100),
#     # padding = c(25, 25, 20, 25, 25, 30, 25, 15, 50) # for point.padding
#     padding = c(1, 1, 1.1, 1, 1, 1.75, 1, 2, 1) # for box.padding
#   ) #MA was 500 50 1.2 but it didn't work once I set expand to F
  
    if(increment != 0) {
      format_value = function(x){return(paste0(dollar, x))}
      percent = ""
    } else if(unit == "%"){
      format_value = append_unit(dollar, unit)
      percent = "%"
    } else {
      format_value = append_unit(dollar, "")
      percent = ""
    }
    
map <- map |>
  left_join(adjustments, by = "abbr") |>
  mutate(
    x = coalesce(x + x_adj, x),
    y = coalesce(y + y_adj, y)
  ) |>
  select(-x_adj, -y_adj) |>
  mutate(label = format_value(Value),
         label = case_when(Value < 0.01 & Value > 0 ~ paste0("<", dollar, "0.01", percent), 
                           Value > -0.01 & Value < 0 ~ paste0(">-", dollar, "0.01", percent), #this will look kind of weird but idk what else to do to avoid signif making super long labels for very small numbers
                           T ~ label),
                  label = gsub("NA", "", label)) #Remove "NA" label
wv = map |> filter(abbr == "WV")
wv_label_length = nchar(wv$label)
if(wv_label_length > 4){
  map <- map|>
    filter(abbr != "WV")
  plot <- plot +
    geom_text(
        data = wv,
        aes(x = x, y = y, label = label, color = text_color),
        size = font_size,
        family = font,
        fontface = "bold",
        angle = 45
      )
}
# ma = map |> filter(abbr == "MA")
# map <- map|>
#   filter(abbr != "MA")
# plot <- plot +
#   geom_text(
#       data = ma,
#       aes(x = x, y = y, label = label, color = text_color),
#       size = font_size*0.8,
#       family = font,
#       fontface = "bold",
#       angle = 12.5
#     )

plot <- plot + 
      geom_text(data = map %>% filter(!(abbr %in% c("DC", repels$abbr))), 
         aes(x = x, y = y, label = label, color = text_color), 
         size = font_size, 
         family = font,
         fontface = "bold") +
      scale_color_identity()

for (i in 1:nrow(adjustments)) {
  row <- repels[i, ]
  
  plot <- plot +
    geom_text_repel(
      data = map %>% filter(abbr == row$abbr),
      aes(x = x, y = y, label = label),
      nudge_x = row$x_nudge,
      nudge_y = row$y_nudge,
      size = font_size,
      family = font,
      fontface = "bold",
      color = palette$text_color,
      box.padding = row$padding,
      segment.size = 0.8,
      force_pull = 0
      ) #if I did it all in one call the repels would repel each other which is a huge mess
}
      
dc_row <- map |> filter(fips == "11", name == "District of Columbia")
  if (nrow(dc_row) == 1) {
    dc_row <- dc_row %>%
      mutate(label = paste0("DC: ", label))
    
  plot <- plot +
    geom_label(
      data = dc_row,
      aes(x = x, y = y, label = label),
      size = font_size,
      family = font,
      fontface = "bold",
      fill = dc_row$bin_color,
      color = dc_row$text_color,
      label.size = 1 #state border thickness
    )
  }
      
      return(plot)
}
```

#merge_by_MSA
```{r}
merge_by_MSA <- function(county_map, region_fips){
   if(!exists("MSAs")){
    stop("Read in MSAs_crosswalk.csv as MSAs.")
  }
  if("Type" %in% colnames(county_map)) {
    stop("Merging categorical variable (Type) by MSA is not implemented.")
  }
  map <- county_map |>
      left_join(MSAs, by = "fips") |>
        mutate(metro_name = if_else(is.na(metro_name), name, metro_name),
        metro_name = if_else(str_detect(county, "Ag District"), county, metro_name) #Although I won't really be using this option for Ag Maps, this still seems like good practice
        )
    if(!is.na(region_fips)[1]){
      map <- map |>
        group_by(metro_name) |>
        mutate(num_counties = n())|> #if region_fips overlaps with MSAs, we don't merge that MSA
        filter(!(fips %in% region_fips)) |> #so that partially overlapping MSAs have the right populations
      mutate(metro_name = if_else(num_counties == n(), metro_name, name)) |> #drop CBSA Title/name for counties removed because they are in region_fips)
      ungroup()
    }
  
  #there may be a better way to do this
      aggregate_cols = setdiff(colnames(map), c("fips", "county", "abbr", "state", "x", "y", "name", "geometry", "cbsa_code", "metro_name")) #this only works because I remove all columns but fips and Value from the data fed into map(), but in the future, I may want to allow data to have other columns that do other things, so this isn't best practice
      
      map <- map |>
      group_by(metro_name, cbsa_code) |> #don't really need to be grouping by CBSA code here
      summarize(
        geometry = st_union(geometry),
        #across(contains("pop"), ~sum(.x)),
        #cutoff = sum(cutoff, na.rm = T), #cutoff is almost always something that can be aggregated
        across(all_of(aggregate_cols), ~sum(.x, na.rm = T))
        ) |>
      ungroup() |>
        mutate(Value = if_else(Value == 0, NA, Value))

coords <- st_coordinates(st_centroid(map))
map <- map |>
  mutate(x = coords[, 1],
         y = coords[, 2],
         name = metro_name)

return(map)
}
```